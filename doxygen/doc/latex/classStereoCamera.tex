\section{Stereo\+Camera Class Reference}
\label{classStereoCamera}\index{Stereo\+Camera@{Stereo\+Camera}}


The base class defining stereo camera.  




{\ttfamily \#include $<$stereo\+Camera.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStereoCamera_a11256fe5a509436abc714a594b6cc801}{Stereo\+Camera} (bool rectify=true)
\begin{DoxyCompactList}\small\item\em Default Constructor. \end{DoxyCompactList}\item 
\hyperlink{classStereoCamera_a0c2cd4c7b5a0cdb96370c29a42601f40}{Stereo\+Camera} (yarp\+::os\+::\+Resource\+Finder \&rf, bool rectify=true)
\begin{DoxyCompactList}\small\item\em Costructor for initialization from file. \end{DoxyCompactList}\item 
\hyperlink{classStereoCamera_a5bfcf3ef7c9d45802bacbf040e7ca112}{Stereo\+Camera} (\hyperlink{classCamera}{Camera} First, \hyperlink{classCamera}{Camera} Second, bool rectify=true)
\begin{DoxyCompactList}\small\item\em Constructor for initialization using two calibrated cameras. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a067e1e94a48cb390491fea0f6748dda8}{init\+E\+L\+A\+S} (yarp\+::os\+::\+Resource\+Finder \&rf)
\begin{DoxyCompactList}\small\item\em Initialization of E\+L\+A\+S parameters. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a398f45eeefe7979a834659cfbb7a6961}{stereo\+Calibration} (vector$<$ string $>$ image\+List, int board\+Width, int board\+Height, float sqsize=1.\+0)
\begin{DoxyCompactList}\small\item\em It performs the stereo camera calibration. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a9f06cd4b170ad0ba45b681ee93d64851}{save\+Calibration} (string extrinsic\+File\+Path, string intrinsic\+File\+Path)
\begin{DoxyCompactList}\small\item\em It saves the calibration. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a5e24f7d17a11adb4a6310df7f7e2de5b}{set\+Images} (Ipl\+Image $\ast$first\+Img, Ipl\+Image $\ast$second\+Img)
\begin{DoxyCompactList}\small\item\em It stores in memory a couple of images. \end{DoxyCompactList}\item 
cv\+::\+Mat \hyperlink{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}{find\+Match} (bool visualize=false, double displacement=20.\+0, double radius=200.\+0)
\begin{DoxyCompactList}\small\item\em It finds matches between two images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity} (bool best=true, int uniqueness\+Ratio=15, int speckle\+Window\+Size=50, int speckle\+Range=16, int number\+Of\+Disparities=64, int S\+A\+D\+Window\+Size=7, int min\+Disparity=0, int pre\+Filter\+Cap=63, int disp12\+Max\+Diff=0)
\begin{DoxyCompactList}\small\item\em It computes the Disparity Map using H. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a2751f357e5fabc7099303d45425208d7}{undistort\+Images} ()
\begin{DoxyCompactList}\small\item\em It undistorts the images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_adf155975709fdbf09d3133899d074a02}{horn} (Mat \&K1, Mat \&K2, vector$<$ Point2f $>$ \&Points1, vector$<$ Point2f $>$ \&Points2, Mat \&Rot, Mat \&Tras)
\begin{DoxyCompactList}\small\item\em It performs the horn relative orientations algorithm i.\+e. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a36dae897d07544e8faca8c90216173a6}{horn\+Relative\+Orientations} ()
\begin{DoxyCompactList}\small\item\em It performs the horn relative orientations, all the parameters are assumed initialized in the \hyperlink{classStereoCamera}{Stereo\+Camera} object. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a3c8ef84424fa111c63437a3db8f04333}{triangulation} (Point2f \&point1, Point2f \&point2)
\begin{DoxyCompactList}\small\item\em It performs the triangulation using the stored in the internal P1 and P2 3x4 \hyperlink{classCamera}{Camera} Matrices. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_ab68c8d3bd07f542243d681fbe8c8c6b7}{triangulation} (Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)
\begin{DoxyCompactList}\small\item\em It performs the triangulation (H\+Z Chap 12.\+2 homogenous solution). \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_aaef25d8723eefdbab6e27c348492126b}{triangulation\+L\+S} (Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)
\begin{DoxyCompactList}\small\item\em It performs the least square triangulation (H\+Z Chap 12.\+2 Inhomogenous solution). \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a2fcd3e1767bcf04716b0e2ac76098430}{metric\+Triangulation} (Point2f \&point1, double th\+Meters=10)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a3cf53fac6336eea107a26bd5cdbbdd03}{metric\+Triangulation} (Point2f \&point1, Mat \&H, double th\+Meters=10)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a761ea623c4cde38b4fa1d798ef09b7ae}{triangulate\+Known\+Disparity} (float u, float v, float d, Mat \&H)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image and the disparity between the two R\+E\+C\+T\+I\+F\+I\+E\+D images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ab2eded08bca185ac22cd6343cb4c85c8}{estimate\+Essential} ()
\begin{DoxyCompactList}\small\item\em It estimates the essential matrix (3x3) E between two views. \end{DoxyCompactList}\item 
bool \hyperlink{classStereoCamera_a180388e93b654802c7c56c18d206214b}{essential\+Decomposition} ()
\begin{DoxyCompactList}\small\item\em It decomposes the essential matrix in Rotation and Translation between the two views. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a245346dbef63e13807c5cd9160803d25}{chierality} (Mat \&R1, Mat \&R2, Mat \&t1, Mat \&t2, Mat \&R, Mat \&t, Vector$<$ Point2f $>$ points1, Vector$<$ Point2f $>$ points2)
\begin{DoxyCompactList}\small\item\em It performs the chierality test\+: given a couple of rotation matrices, translation vectors and matches it finds the correct rotation and translation s.\+t. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a1ed40435ff66e171885c8b2be6987ef7}{get\+Im\+Left} () const 
\begin{DoxyCompactList}\small\item\em It returns the left (first) image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_ade2fcf87e8afab6cf836b979fd048110}{get\+Im\+Right} () const 
\begin{DoxyCompactList}\small\item\em It returns the right (second) image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a8beef7e6d56b98f531ceeb2ed6778c28}{get\+Im\+Left\+Und} () const 
\begin{DoxyCompactList}\small\item\em It returns the left undistorted image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a915c0da2c83bca6776152e8d0205e9d1}{get\+Im\+Right\+Und} () const 
\begin{DoxyCompactList}\small\item\em It returns the right undistorted image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a7e9dc528c0a2b8d587fbe80738063a34}{get\+Disparity} () const 
\begin{DoxyCompactList}\small\item\em It returns the disparity image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_af77824b3c5785cac11e585ef698c2537}{get\+Disparity16} () const 
\begin{DoxyCompactList}\small\item\em It returns the disparity image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a7de1dc2bd3416e4d9dcb4f6a373297b5}{get\+Q} () const 
\begin{DoxyCompactList}\small\item\em It returns the 4x4 disparity-\/to-\/depth mapping matrix. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_aef0ec58b3e5cf02f7b925340c57ee477}{get\+Kleft} () const 
\begin{DoxyCompactList}\small\item\em It returns the 3x3 left camera matrix. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a6c2d8ae33c7e8f1e8e4d6f38ffe65b94}{get\+Kright} () const 
\begin{DoxyCompactList}\small\item\em It returns the 3x3 right camera matrix. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a57235f5bf074b5cd96d75d0d1662c26c}{get\+Fundamental} () const 
\begin{DoxyCompactList}\small\item\em It returns the 3x3 fundamental matrix. \end{DoxyCompactList}\item 
vector$<$ Point2f $>$ \hyperlink{classStereoCamera_a42908347f3f8457e4569a9e6b7e19118}{get\+Match\+Left} () const 
\begin{DoxyCompactList}\small\item\em It returns the pixel coordinates of the matches in the left image. \end{DoxyCompactList}\item 
vector$<$ Point2f $>$ \hyperlink{classStereoCamera_a24e61743d392be57d4d2e5b88e55abd1}{get\+Match\+Right} () const 
\begin{DoxyCompactList}\small\item\em It returns the pixel coordinates of the matches in the right image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_ae914424daf5b615dea6d7d09921f0b19}{get\+Translation} () const 
\begin{DoxyCompactList}\small\item\em It returns the translation vector between the two cameras. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a2baf8c2d797f2ae0d7d00d8e41250db0}{get\+Rotation} () const 
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the two cameras. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_aa1b2b60fa8d72cb8928e8db58842e65f}{get\+Mapper\+L} () const 
\begin{DoxyCompactList}\small\item\em It returns the mapping between the original left camera and the rectified left camera. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_aceec69a43430b8445e66e907a179e57e}{get\+Mapper\+R} () const 
\begin{DoxyCompactList}\small\item\em It returns the mapping between the original right camera and the rectified right camera. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_ae3421ead8d31c84c726a27e3b702d798}{get\+R\+Lrect} () const 
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the original left camera and the rectified left camera. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a41eb4d6884d233cf9b1a3cdc226f7028}{get\+R\+Rrect} () const 
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the original right camera and the rectified right camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a1329b3894d527e1505618f57a1304624}{set\+Rotation} (Mat \&Rot, int mode=0)
\begin{DoxyCompactList}\small\item\em It sets the rotation matrix (if known) between the first and the second camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a7b10f1218e8e70f47b22080ba1820d39}{set\+Translation} (Mat \&Tras, int mul=0)
\begin{DoxyCompactList}\small\item\em It sets the translation vector (if known) between the first and the second camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a54754623497c8dddb61f520e17f465f8}{set\+Intrinsics} (Mat \&K1, Mat \&K2, Mat \&Dist1, Mat \&Dist2)
\begin{DoxyCompactList}\small\item\em It sets the intrinsic parameters. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ae5ac866c6d4b6c4819b01a918e7b61e0}{rectify\+Images} ()
\begin{DoxyCompactList}\small\item\em The method rectifies the two images\+: it transform each image plane such that pairs conjugate epipolar lines become collinear and parallel to one of the image axes (i.\+e. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a0bd4492f7f87862955da0bc5d0042cc8}{get\+L\+Rectified} ()
\begin{DoxyCompactList}\small\item\em The method returns the first rectified image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_aaf4ba8eaa338ff24db1196849a96e5e9}{get\+R\+Rectified} ()
\begin{DoxyCompactList}\small\item\em The method returns the second rectified image. \end{DoxyCompactList}\item 
vector$<$ Point2f $>$ \hyperlink{classStereoCamera_a03406c9d31c1b765a8d6ef9641222309}{project\+Points3\+D} (string camera, vector$<$ Point3f $>$ \&points3\+D, Mat \&H)
\begin{DoxyCompactList}\small\item\em The method returns the 2\+D projection of a set of 3\+D points in the cartesian space to the specified camera. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a52ef2f3401488e5c4fa6badd1336f96d}{compute\+World\+Image} (Mat \&H)
\begin{DoxyCompactList}\small\item\em The method returns a 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a3edeb24b68ee4266f89982533ad1e9bf}{get\+Dist\+Coeff\+Right} ()
\begin{DoxyCompactList}\small\item\em It returns the 5x1 right distortion coefficients. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a4830201154ab288bd93f6cceb2c2daf5}{get\+Dist\+Coeff\+Left} ()
\begin{DoxyCompactList}\small\item\em It returns the 5x1 left distortion coefficients. \end{DoxyCompactList}\item 
Point2f \hyperlink{classStereoCamera_af64550bb8a7a665930dee5eea87b7e47}{get\+Distorted\+Pixel} (int u, int v, int cam=1)
\begin{DoxyCompactList}\small\item\em Given the u,v pixel coordinates in the undistorted image the method returns the original position of the pixel in the distorted frame. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a6580ff03c7cec5c385ec717f9c018e21}{draw\+Matches} ()
\begin{DoxyCompactList}\small\item\em The method returns a 3-\/\+Channels 8bit image with the image matches. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ae683fafa11ea73e4b4c278402be259b6}{set\+Matches} (std\+::vector$<$ cv\+::\+Point2f $>$ \&points\+L, std\+::vector$<$ cv\+::\+Point2f $>$ \&points\+R)
\begin{DoxyCompactList}\small\item\em The function initialize the matches of the current image pair. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a9ecb303d7b36eaf5f086d8ddebd29b95}{set\+Expected\+Position} (Mat \&Rot, Mat \&Tran)
\begin{DoxyCompactList}\small\item\em The function set the expected Rotation and Translation parameters for the current image pair. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a3fe4e87322f8644cd21ce06e8522c815}{Ffrom\+P} (Mat \&P1, Mat \&P2)
\begin{DoxyCompactList}\small\item\em The function computes the fundamental matrix starting from known camera matrices. \end{DoxyCompactList}\item 
Point2f \hyperlink{classStereoCamera_a3d8fde0cbd4604085b883f22cc606c01}{from\+Rectified\+To\+Original} (int u, int v, int camera)
\begin{DoxyCompactList}\small\item\em Given the u,v pixel coordinates in the rectified image the method returns the position of the pixel in the non-\/rectified frame. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The base class defining stereo camera. 

It allows to calibrate the cameras, to undistort a pair of images, to find matches between two images, to triangulate points and to estimate motion between two images. The basic assumption is that the two images come from a stereo camera, however this class works also with two arbitrary images. 

Definition at line 86 of file stereo\+Camera.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Stereo\+Camera(bool rectify=true)}]{\setlength{\rightskip}{0pt plus 5cm}Stereo\+Camera\+::\+Stereo\+Camera (
\begin{DoxyParamCaption}
\item[{bool}]{rectify = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a11256fe5a509436abc714a594b6cc801}


Default Constructor. 

You should initialize all the intrinsic and extrinsic parameters using the provided methods. 

Definition at line 58 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
58                                        \{
59     this->mutex=\textcolor{keyword}{new} Semaphore(1);
60     this->rectify=rectify;
61     this->epipolarTh=0.01;
62 
63 \textcolor{preprocessor}{#ifndef USING\_GPU}
64     cv::initModule\_nonfree();
65 \textcolor{preprocessor}{#endif }
66 
67     use\_elas = \textcolor{keyword}{false};
68 
69 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Stereo\+Camera(yarp\+::os\+::\+Resource\+Finder \&rf, bool rectify=true)}]{\setlength{\rightskip}{0pt plus 5cm}Stereo\+Camera\+::\+Stereo\+Camera (
\begin{DoxyParamCaption}
\item[{yarp\+::os\+::\+Resource\+Finder \&}]{rf, }
\item[{bool}]{rectify = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a0c2cd4c7b5a0cdb96370c29a42601f40}


Costructor for initialization from file. 


\begin{DoxyParams}{Parameters}
{\em rf} & is the config file generated by the stereo\+Calib module. \\
\hline
\end{DoxyParams}


Definition at line 71 of file stereo\+Camera.\+cpp.



References set\+Intrinsics(), set\+Rotation(), and set\+Translation().


\begin{DoxyCode}
71                                                                  \{
72         Mat KL, KR, DistL, DistR, R, T;
73         loadStereoParameters(rf,KL,KR,DistL,DistR,R,T);
74         this->mutex= \textcolor{keyword}{new} Semaphore(1);
75         this->setIntrinsics(KL,KR,DistL,DistR);
76         this->setRotation(R,0);
77         this->setTranslation(T,0);
78 
79         this->cameraChanged=\textcolor{keyword}{true};
80         this->epipolarTh=0.01;
81         this->rectify=rectify;
82         buildUndistortRemap();
83 
84 \textcolor{preprocessor}{    #ifndef USING\_GPU}
85         cv::initModule\_nonfree();
86 \textcolor{preprocessor}{    #endif }
87 
88     use\_elas = \textcolor{keyword}{false};
89 
90 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Stereo\+Camera(\+Camera First, Camera Second, bool rectify=true)}]{\setlength{\rightskip}{0pt plus 5cm}Stereo\+Camera\+::\+Stereo\+Camera (
\begin{DoxyParamCaption}
\item[{{\bf Camera}}]{First, }
\item[{{\bf Camera}}]{Second, }
\item[{bool}]{rectify = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a5bfcf3ef7c9d45802bacbf040e7ca112}


Constructor for initialization using two calibrated cameras. 

\begin{DoxyNote}{Note}
Only intrinsic parameters are initialized. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em First} & the first camera (Left eye is assumed but you can use any arbitrary camera). The 3\+D point coordinates have this reference system. \\
\hline
{\em Second} & the second camera (Right eye is assumed). \\
\hline
\end{DoxyParams}


Definition at line 92 of file stereo\+Camera.\+cpp.



References Camera\+::get\+Camera\+Matrix(), and Camera\+::get\+Dist\+Vector().


\begin{DoxyCode}
92                                                                  \{
93     this->Kleft=Left.getCameraMatrix();
94     this->DistL=Left.getDistVector();
95 
96     this->Kright=Right.getCameraMatrix();
97     this->DistR=Right.getDistVector();
98     this->mutex=\textcolor{keyword}{new} Semaphore(1);
99     this->cameraChanged=\textcolor{keyword}{true};
100     this->rectify=rectify;
101     this->epipolarTh=0.01;
102     buildUndistortRemap();
103 
104 \textcolor{preprocessor}{#ifndef USING\_GPU}
105     cv::initModule\_nonfree();
106 \textcolor{preprocessor}{#endif }
107 
108     use\_elas = \textcolor{keyword}{false};
109 
110 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{Stereo\+Camera@{Stereo\+Camera}!chierality@{chierality}}
\index{chierality@{chierality}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{chierality(\+Mat \&\+R1, Mat \&\+R2, Mat \&t1, Mat \&t2, Mat \&\+R, Mat \&t, Vector$<$ Point2f $>$ points1, Vector$<$ Point2f $>$ points2)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::chierality (
\begin{DoxyParamCaption}
\item[{Mat \&}]{R1, }
\item[{Mat \&}]{R2, }
\item[{Mat \&}]{t1, }
\item[{Mat \&}]{t2, }
\item[{Mat \&}]{R, }
\item[{Mat \&}]{t, }
\item[{Vector$<$ Point2f $>$}]{points1, }
\item[{Vector$<$ Point2f $>$}]{points2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a245346dbef63e13807c5cd9160803d25}


It performs the chierality test\+: given a couple of rotation matrices, translation vectors and matches it finds the correct rotation and translation s.\+t. 

the triangulated points have their depth coordinates greater than 0. The method is used by essential\+Decomposition, indeed an essential matrix generates 2 rotations and 2 translation. The chierality test is needed in order to discard wrong rototranslations. 
\begin{DoxyParams}{Parameters}
{\em R1} & first rotation 3x3 matrix \\
\hline
{\em R2} & second rotation 3x3 matrix \\
\hline
{\em t1} & first translation 3x1 matrix \\
\hline
{\em t2} & second translation 3x1 matrix \\
\hline
{\em R} & output rotation matrix \\
\hline
{\em t} & output translation matrix \\
\hline
{\em points1} & corrispondences in the first image \\
\hline
{\em points2} & corrispondences in the second image \\
\hline
\end{DoxyParams}


Definition at line 1088 of file stereo\+Camera.\+cpp.



References triangulation().



Referenced by essential\+Decomposition().


\begin{DoxyCode}
1088                                                                                                            
                                 \{
1089 
1090         Mat A= Mat::eye(3,4,CV\_64FC1);
1091         Mat P1 = this->Kleft*Mat::eye(3, 4, CV\_64F);
1092 
1093         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R1.rows; i++)
1094          \{
1095              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1096              \textcolor{keywordtype}{double}* MRi = R1.ptr<\textcolor{keywordtype}{double}>(i);
1097                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R1.cols; j++)
1098                      Mi[j]=MRi[j];
1099          \}
1100          
1101         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t1.rows; i++)
1102          \{
1103              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1104              \textcolor{keywordtype}{double}* MRi = t1.ptr<\textcolor{keywordtype}{double}>(i);
1105              Mi[3]=MRi[0];
1106          \}
1107 
1108         Mat P2=this->Kright*A;
1109         A= Mat::eye(3,4,CV\_64FC1);
1110         
1111         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R2.rows; i++)
1112          \{
1113              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1114              \textcolor{keywordtype}{double}* MRi = R2.ptr<\textcolor{keywordtype}{double}>(i);
1115                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R2.cols; j++)
1116                      Mi[j]=MRi[j];
1117          \}
1118         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t2.rows; i++)
1119          \{
1120              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1121              \textcolor{keywordtype}{double}* MRi = t2.ptr<\textcolor{keywordtype}{double}>(i);
1122              Mi[3]=MRi[0];
1123          \}
1124         Mat P3=this->Kright*A;
1125         A= Mat::eye(3,4,CV\_64FC1);
1126 
1127         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R1.rows; i++)
1128          \{
1129              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1130              \textcolor{keywordtype}{double}* MRi = R1.ptr<\textcolor{keywordtype}{double}>(i);
1131              \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R1.cols; j++)
1132                      Mi[j]=MRi[j];
1133          \}
1134         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t1.rows; i++)
1135          \{
1136              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1137              \textcolor{keywordtype}{double}* MRi = t2.ptr<\textcolor{keywordtype}{double}>(i);
1138              Mi[3]=MRi[0];
1139          \}
1140         Mat P4=this->Kright*A;
1141         A= Mat::eye(3,4,CV\_64FC1);
1142 
1143 
1144             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R2.rows; i++)
1145      \{
1146          \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1147          \textcolor{keywordtype}{double}* MRi = R2.ptr<\textcolor{keywordtype}{double}>(i);
1148             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R2.cols; j++)
1149                  Mi[j]=MRi[j];
1150      \}
1151     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t2.rows; i++)
1152      \{
1153          \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1154          \textcolor{keywordtype}{double}* MRi = t1.ptr<\textcolor{keywordtype}{double}>(i);
1155          Mi[3]=MRi[0];
1156      \}
1157      Mat P5=this->Kright*A;
1158 
1159      \textcolor{keywordtype}{int} err1=0; \textcolor{comment}{//R1 t1}
1160      \textcolor{keywordtype}{int} err2=0; \textcolor{comment}{//R2 t2}
1161      \textcolor{keywordtype}{int} err3=0; \textcolor{comment}{//R1 t2}
1162      \textcolor{keywordtype}{int} err4=0; \textcolor{comment}{//R2 t1}
1163      Mat point(4,1,CV\_64FC1);
1164 
1165          \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<(int) InliersL.size(); i++) 
1166          \{
1167              Point3f point3D=triangulation(points1[i],points2[i],P1,P2);
1168              Mat H1=buildRotTras(R1,t1);
1169              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1170              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1171              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1172              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1173              Mat rotatedPoint=H1*point;
1174 
1175              \textcolor{comment}{//fprintf(stdout, "Camera P2 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1176 
1177              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1178                  err1++;                 
1179              \}
1180              point3D=triangulation(points1[i],points2[i],P1,P3);
1181              Mat H2=buildRotTras(R2,t2);
1182              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1183              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1184              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1185              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1186              rotatedPoint=H2*point;  
1187              \textcolor{comment}{//fprintf(stdout, "Camera P3 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1188 
1189              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1190                  err2++;                 
1191              \}
1192                           
1193              point3D=triangulation(points1[i],points2[i],P1,P4);   
1194              Mat H3=buildRotTras(R1,t2);
1195              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1196              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1197              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1198              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1199              rotatedPoint=H3*point;
1200              \textcolor{comment}{//fprintf(stdout, "Camera P4 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1201 
1202              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1203                  err3++;                 
1204              \} 
1205              
1206              point3D=triangulation(points1[i],points2[i],P1,P5);
1207              Mat H4=buildRotTras(R2,t1);
1208              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1209              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1210              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1211              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1212              rotatedPoint=H4*point;
1213              \textcolor{comment}{//fprintf(stdout, "Camera P5 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1214              
1215              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1216                  err4++;                 
1217              \} 
1218 
1219          \}
1220 
1221     \textcolor{comment}{/*printMatrix(R1);}
1222 \textcolor{comment}{    printMatrix(t1);}
1223 \textcolor{comment}{    printMatrix(R2);}
1224 \textcolor{comment}{    printMatrix(t2);*/}
1225     \textcolor{comment}{//fprintf(stdout, "Inliers: %d, %d, \(\backslash\)n",points1.size(),points2.size());}
1226     \textcolor{comment}{//fprintf(stdout, "errors: %d, %d, %d, %d, \(\backslash\)n",err1,err2,err3,err4);}
1227 
1228       \textcolor{keywordtype}{double} minErr=10000;
1229       \textcolor{keywordtype}{double} secondErr=minErr;
1230 
1231       \textcolor{keywordtype}{int} idx=0;
1232       \textcolor{keywordflow}{if}(err1<minErr && t1.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1233       \{
1234         idx=1;
1235         secondErr=minErr;
1236         minErr=err1;
1237       \}
1238         
1239       \textcolor{keywordflow}{if}(err2<minErr && t2.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1240       \{
1241         idx=2;
1242         secondErr=minErr;
1243         minErr=err2;
1244       \} 
1245       \textcolor{keywordflow}{if}(err3<minErr && t2.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1246       \{
1247         idx=3;
1248         secondErr=minErr;
1249         minErr=err3;
1250       \}
1251       \textcolor{keywordflow}{if}(err4<minErr && t1.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1252       \{
1253         idx=4;
1254         secondErr=minErr;
1255         minErr=err4;
1256       \}
1257 
1258       \textcolor{comment}{/*if(secondErr==minErr)}
1259 \textcolor{comment}{      \{}
1260 \textcolor{comment}{        R=this->R;}
1261 \textcolor{comment}{        t=this->T;}
1262 \textcolor{comment}{        return;      }
1263 \textcolor{comment}{      \}*/}
1264       \textcolor{keywordflow}{if}(idx==1) \{
1265             R=R1;
1266             t=t1;
1267             \textcolor{keywordflow}{return};
1268        \}
1269       \textcolor{keywordflow}{if}(idx==2) \{
1270             R=R2;
1271             t=t2;
1272             \textcolor{keywordflow}{return};
1273        \}
1274       \textcolor{keywordflow}{if}(idx==3) \{
1275             R=R1;
1276             t=t2;
1277             \textcolor{keywordflow}{return};
1278        \}
1279       \textcolor{keywordflow}{if}(idx==4) \{
1280             R=R2;
1281             t=t1;
1282             \textcolor{keywordflow}{return};
1283        \}
1284 
1285 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!compute\+Disparity@{compute\+Disparity}}
\index{compute\+Disparity@{compute\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{compute\+Disparity(bool best=true, int uniqueness\+Ratio=15, int speckle\+Window\+Size=50, int speckle\+Range=16, int number\+Of\+Disparities=64, int S\+A\+D\+Window\+Size=7, int min\+Disparity=0, int pre\+Filter\+Cap=63, int disp12\+Max\+Diff=0)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::compute\+Disparity (
\begin{DoxyParamCaption}
\item[{bool}]{best = {\ttfamily true}, }
\item[{int}]{uniqueness\+Ratio = {\ttfamily 15}, }
\item[{int}]{speckle\+Window\+Size = {\ttfamily 50}, }
\item[{int}]{speckle\+Range = {\ttfamily 16}, }
\item[{int}]{number\+Of\+Disparities = {\ttfamily 64}, }
\item[{int}]{S\+A\+D\+Window\+Size = {\ttfamily 7}, }
\item[{int}]{min\+Disparity = {\ttfamily 0}, }
\item[{int}]{pre\+Filter\+Cap = {\ttfamily 63}, }
\item[{int}]{disp12\+Max\+Diff = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}


It computes the Disparity Map using H. 

Hirschmuller Algorithm (C\+V\+P\+R 2006) (see stereo\+Disparity). 
\begin{DoxyParams}{Parameters}
{\em best} & set equal true for better accuracy, equal false for save computation. \\
\hline
{\em uniqueness\+Ratio} & The margin in percents by which the best (minimum) computed cost function value should win the second best value to consider the found match correct. Normally, some value within 5-\/15 range is good enough. \\
\hline
{\em speckle\+Window\+Size} & Maximum size of smooth disparity regions to consider them noise speckles and invdalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in 50-\/200 range. \\
\hline
{\em speckle\+Range} & Maximum disparity variation within each connected component. If you do speckle filtering, set it to some positive value, multiple of 16. Normally, 16 or 32 is good enough. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Run the calibration or set all the parameters before using this method. 
\end{DoxyNote}


Definition at line 518 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
521 \{
522     \textcolor{keywordflow}{if} (this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty())
523     \{
524         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
525         \textcolor{keywordflow}{return};
526     \}
527 
528     \textcolor{keywordflow}{if} (this->imleft.empty() || this->imright.empty())
529     \{
530         cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
531         \textcolor{keywordflow}{return};
532     \}
533 
534     Size img\_size=this->imleft.size();
535 
536     \textcolor{keywordflow}{if} (cameraChanged)
537     \{
538         mutex->wait();
539         stereoRectify(this->Kleft, this->DistL, this->Kright, this->DistR, img\_size,
540                       this->R, this->T, this->RLrect, this->RRrect, this->PLrect,
541                       this->PRrect, this->Q, -1);
542 
543         \textcolor{keywordflow}{if} (!rectify)
544         \{
545             this->RLrect=Mat::eye(3,3,CV\_32FC1);
546             this->RRrect=Mat::eye(3,3,CV\_32FC1);
547             this->PLrect=this->Kleft;
548             this->PRrect=this->Kright;
549         \}
550         mutex->post();
551     \}
552 
553     \textcolor{keywordflow}{if} (cameraChanged)
554     \{
555         initUndistortRectifyMap(this->Kleft, this->DistL, this->RLrect, this->PLrect,
556                                 img\_size, CV\_32FC1, this->map11, this->map12);
557         initUndistortRectifyMap(this->Kright,  this->DistR, this->RRrect, this->PRrect,
558                                 img\_size, CV\_32FC1, this->map21, this->map22);
559     \}
560     
561     Mat img1r, img2r;
562     remap(this->imleft, img1r, this->map11, this->map12, cv::INTER\_LINEAR);
563     remap(this->imright, img2r, this->map21,this->map22, cv::INTER\_LINEAR);
564 
565     imgLeftRect = img1r;
566     imgRightRect = img2r;
567 
568     Mat disp,disp8,map,dispTemp;
569 
570     \textcolor{keywordflow}{if} (use\_elas)
571     \{
572         
573         elaswrap->compute\_disparity(img1r, img2r, disp, numberOfDisparities);
574 
575         map = disp * (255.0 / numberOfDisparities);
576         \textcolor{comment}{//threshold(map, map, 0, 255.0, THRESH\_TOZERO);}
577 
578     \} \textcolor{keywordflow}{else}
579     \{
580         StereoSGBM sgbm;
581         sgbm.preFilterCap =         preFilterCap; \textcolor{comment}{//63}
582         sgbm.SADWindowSize =        SADWindowSize;
583         \textcolor{keywordtype}{int} cn =                    this->imleft.channels();
584         sgbm.P1 =                   8*cn*sgbm.SADWindowSize*sgbm.SADWindowSize;
585         sgbm.P2 =                   32*cn*sgbm.SADWindowSize*sgbm.SADWindowSize;
586         sgbm.minDisparity =         minDisparity; \textcolor{comment}{//-15}
587         sgbm.numberOfDisparities =  numberOfDisparities;
588         sgbm.uniquenessRatio =      uniquenessRatio; \textcolor{comment}{//22}
589         sgbm.speckleWindowSize =    speckleWindowSize; \textcolor{comment}{//100}
590         sgbm.speckleRange =         speckleRange; \textcolor{comment}{//32}
591         sgbm.disp12MaxDiff =        disp12MaxDiff;
592         sgbm.fullDP =               best; \textcolor{comment}{// alg == STEREO\_HH}
593 
594         sgbm(img1r, img2r, disp);
595 
596         disp.convertTo(map, CV\_32FC1, 1.0,0.0);
597         map.convertTo(map,CV\_32FC1,255/(numberOfDisparities*16.));
598         \textcolor{comment}{//normalize(map,map, 0, 255, cv::NORM\_MINMAX, CV\_8UC1);}
599 
600     \}
601     
602     \textcolor{keywordflow}{if} (cameraChanged)
603     \{
604         this->mutex->wait();
605         Mat inverseMapL(map.rows*map.cols,1,CV\_32FC2);
606         Mat inverseMapR(map.rows*map.cols,1,CV\_32FC2);
607 
608         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y=0; y<map.rows; y++)
609         \{
610             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x=0; x<map.cols; x++)
611             \{
612                 inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[0]=(\textcolor{keywordtype}{float})x;
613                 inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[1]=(\textcolor{keywordtype}{float})y;
614                 inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[0]=(\textcolor{keywordtype}{float})x;
615                 inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[1]=(\textcolor{keywordtype}{float})y;
616             \}
617         \}
618 
619         undistortPoints(inverseMapL,inverseMapL,this->Kleft,this->DistL,this->RLrect,this->PLrect);
620         undistortPoints(inverseMapR,inverseMapR,this->Kright,this->DistR,this->RRrect,this->PRrect);
621 
622         Mat mapperL=inverseMapL.reshape(2,map.rows);
623         Mat mapperR=inverseMapR.reshape(2,map.rows);
624         this->MapperL=mapperL;
625         this->MapperR=mapperR;
626         this->mutex->post();
627         cameraChanged=false;
628     \}
629 
630     Mat x;
631     remap(map,dispTemp,this->MapperL,x,cv::INTER\_LINEAR);
632     dispTemp.convertTo(disp8,CV\_8U); 
633 
634     this->mutex->wait();
635 
636     this->Disparity = disp8;
637 
638     if (use\_elas)
639         disp.convertTo(disp, CV\_16SC1, 16.0);
640 
641     this->Disparity16 = disp;
642 
643     this->mutex->post();
644 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!compute\+World\+Image@{compute\+World\+Image}}
\index{compute\+World\+Image@{compute\+World\+Image}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{compute\+World\+Image(\+Mat \&\+H)}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::compute\+World\+Image (
\begin{DoxyParamCaption}
\item[{Mat \&}]{H}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a52ef2f3401488e5c4fa6badd1336f96d}


The method returns a 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. 


\begin{DoxyParams}{Parameters}
{\em H} & the transformation from the camera reference system to the H reference system \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. 
\end{DoxyReturn}


Definition at line 2185 of file stereo\+Camera.\+cpp.



References get\+R\+Lrect().


\begin{DoxyCode}
2186 \{
2187 
2188     Mat worldImg(Disparity16.rows,Disparity16.cols,CV\_32FC3);
2189 
2190     \textcolor{keywordflow}{if}(H.empty())
2191         H=H.eye(4,4,CV\_64FC1);
2192 
2193     \textcolor{keywordflow}{if}(Disparity16.empty() || MapperL.empty() || Q.empty())
2194     \{
2195         cout <<\textcolor{stringliteral}{" Run computeDisparity() method first"} << endl;
2196         \textcolor{keywordflow}{return} worldImg;
2197     \}
2198 
2199 
2200     Mat dispTemp;
2201     Mat x;
2202     remap(this->Disparity16,dispTemp,this->MapperL,x,cv::INTER\_LINEAR);
2203     reprojectImageTo3D(dispTemp, worldImg,this->Q,\textcolor{keyword}{true});
2204 
2205     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<worldImg.rows; i++)
2206     \{
2207        \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<worldImg.cols; j++)
2208         \{   
2209             Mat RLrectTmp=this->getRLrect().t();
2210             Mat Tfake = Mat::zeros(0,3,CV\_64F);
2211             Mat P(4,1,CV\_64FC1);
2212             \textcolor{keywordflow}{if}((worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2]>100)
2213             \{
2214                 P.at<\textcolor{keywordtype}{double}>(0,0)=0.0;
2215                 P.at<\textcolor{keywordtype}{double}>(1,0)=0.0;
2216                 P.at<\textcolor{keywordtype}{double}>(2,0)=0.0;
2217                 P.at<\textcolor{keywordtype}{double}>(3,0)=1.0;
2218             \}
2219             \textcolor{keywordflow}{else}
2220             \{
2221                 P.at<\textcolor{keywordtype}{double}>(0,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 0];
2222                 P.at<\textcolor{keywordtype}{double}>(1,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 1];
2223                 P.at<\textcolor{keywordtype}{double}>(2,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2];
2224                 P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2225 
2226                 Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2227                 P=H*Hrect*P;
2228             \}
2229             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 0]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2230             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 1]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2231             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2232         \}
2233     \}
2234     
2235     \textcolor{keywordflow}{return} worldImg;
2236 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!draw\+Matches@{draw\+Matches}}
\index{draw\+Matches@{draw\+Matches}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{draw\+Matches()}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::draw\+Matches (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a6580ff03c7cec5c385ec717f9c018e21}


The method returns a 3-\/\+Channels 8bit image with the image matches. 

\begin{DoxyReturn}{Returns}
The 3-\/\+Channels 8bit image with the image matches. Call \hyperlink{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}{find\+Match()} to retrieve the keypoints first. 
\end{DoxyReturn}


Definition at line 1608 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1609 \{
1610     \textcolor{keywordflow}{if} (this->imleftund.empty() || this->imrightund.empty())
1611     \{
1612         imleftund=imleft;
1613         imrightund=imright;
1614     \}
1615 
1616     Mat matchImg;
1617     vector<KeyPoint> keypoints1(InliersL.size());
1618     vector<KeyPoint> keypoints2(InliersL.size());
1619     vector<DMatch> filteredMatches(InliersL.size());
1620 
1621     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<InliersL.size(); i++)
1622     \{
1623         filteredMatches[i].queryIdx=i;
1624         filteredMatches[i].trainIdx=i;
1625 
1626         keypoints1[i]=cv::KeyPoint(InliersL[i],2);
1627         keypoints2[i]=cv::KeyPoint(InliersR[i],2);
1628     \}
1629 
1630     cv::drawMatches(this->imleftund,keypoints1,this->imrightund,keypoints2,
1631                     filteredMatches,matchImg,Scalar(0,0,255,0),Scalar(0,0,255,0));
1632 
1633     \textcolor{keywordflow}{return} matchImg;
1634 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!essential\+Decomposition@{essential\+Decomposition}}
\index{essential\+Decomposition@{essential\+Decomposition}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{essential\+Decomposition()}]{\setlength{\rightskip}{0pt plus 5cm}bool Stereo\+Camera\+::essential\+Decomposition (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a180388e93b654802c7c56c18d206214b}


It decomposes the essential matrix in Rotation and Translation between the two views. 

The output is stored in the private members R and T. 

Definition at line 991 of file stereo\+Camera.\+cpp.



References chierality().


\begin{DoxyCode}
992 \{
993     \textcolor{keywordflow}{if} (E.empty())
994     \{
995         cout << \textcolor{stringliteral}{"Essential Matrix is empty! Run the estimateEssential first!"} << endl;
996         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
997     \}
998     
999     \textcolor{keywordflow}{if} (this->InliersL.empty())
1000     \{
1001         cout << \textcolor{stringliteral}{"No matches in memory! Run findMatch first!"} << endl;
1002         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1003     \}
1004 
1005     Mat W=Mat(3,3,CV\_64FC1);
1006     W.setTo(0);
1007     W.at<\textcolor{keywordtype}{double}>(0,0)=0;
1008     W.at<\textcolor{keywordtype}{double}>(0,1)=-1;
1009     W.at<\textcolor{keywordtype}{double}>(0,2)=0;
1010 
1011     W.at<\textcolor{keywordtype}{double}>(1,0)=1;
1012     W.at<\textcolor{keywordtype}{double}>(1,1)=0;
1013     W.at<\textcolor{keywordtype}{double}>(1,2)=0;
1014 
1015     W.at<\textcolor{keywordtype}{double}>(2,0)=0;
1016     W.at<\textcolor{keywordtype}{double}>(2,1)=0;
1017     W.at<\textcolor{keywordtype}{double}>(2,2)=1;
1018 
1019     SVD dec(E);
1020     
1021     Mat Y=Mat::eye(3,3,CV\_64FC1);
1022     Y.at<\textcolor{keywordtype}{double}>(2,2)=0.0;
1023     E=dec.u*Y*dec.vt; \textcolor{comment}{// projection to the Essential Matrix space}
1024     
1025     dec(E);
1026 
1027     Mat V=dec.vt;
1028     Mat U=dec.u;
1029 
1030     Mat R1=U*W*V;
1031     Mat R2=U*W.t()*V;
1032     
1033     \textcolor{keywordflow}{if} (determinant(R1)<0 || determinant(R2)<0)
1034     \{
1035         E=-E;
1036         SVD dec2(E);
1037 
1038         V=dec2.vt;
1039         U=dec2.u;
1040         
1041         R1=U*W*V;
1042         R2=U*W.t()*V;
1043     \}
1044 
1045     Mat t1=U(Range(0,3),Range(2,3));
1046     Mat t2=-t1;
1047 
1048     Mat Rnew=Mat(3,3,CV\_64FC1);
1049     Rnew.setTo(0);
1050     Mat tnew=Mat(3,1,CV\_64FC1);
1051 
1052     chierality(R1,R2,t1,t2,Rnew,tnew,this->InliersL,this->InliersR);
1053     
1054     \textcolor{comment}{//double t\_norm=norm(T/norm(T),tnew/norm(tnew));}
1055     \textcolor{comment}{//double r\_norm=norm(R,Rnew);}
1056     
1057     Mat rvec\_new=Mat::zeros(3,1,CV\_64FC1);
1058     Mat rvec\_exp=Mat::zeros(3,1,CV\_64FC1);
1059     Rodrigues(Rnew,rvec\_new);
1060     Rodrigues(R\_exp,rvec\_exp);
1061 
1062     Mat t\_est=(tnew/norm(tnew))*norm(this->T);
1063     
1064     Mat diff\_angles=rvec\_exp-rvec\_new;
1065     Mat diff\_tran=T\_exp-t\_est;
1066     
1067     fprintf(stdout,\textcolor{stringliteral}{"Angles Differences: %f %f %f\(\backslash\)n"},diff\_angles.at<\textcolor{keywordtype}{double}>(0,0),diff\_angles.at<\textcolor{keywordtype}{double}>(1,0)
      ,diff\_angles.at<\textcolor{keywordtype}{double}>(2,0));
1068     fprintf(stdout,\textcolor{stringliteral}{"Translation Differences: %f %f %f\(\backslash\)n"},diff\_tran.at<\textcolor{keywordtype}{double}>(0,0),diff\_tran.at<\textcolor{keywordtype}{double}>(1,0
      ),diff\_tran.at<\textcolor{keywordtype}{double}>(2,0));    
1069     
1070     \textcolor{comment}{// Magic numbers: rvec\_new are the rotation angles, only vergence (rvec\_new(1,0)) is allowed to be
       large}
1071     \textcolor{comment}{// t\_est is the translation estimated, it can change a little bit when joint 4 of the head is moving}
1072     \textcolor{keywordflow}{if} (fabs(diff\_angles.at<\textcolor{keywordtype}{double}>(0,0))<0.15 && fabs(diff\_angles.at<\textcolor{keywordtype}{double}>(1,0))<0.15 && fabs(
      diff\_angles.at<\textcolor{keywordtype}{double}>(2,0))<0.15 &&
1073         fabs(diff\_tran.at<\textcolor{keywordtype}{double}>(0,0))<0.01 && fabs(diff\_tran.at<\textcolor{keywordtype}{double}>(1,0))<0.01  && fabs(diff\_tran.at<\textcolor{keywordtype}{
      double}>(2,0))<0.01)    
1074     \{
1075         this->mutex->wait();
1076         this->R=Rnew;
1077         this->T=t\_est;
1078         this->updatePMatrix();
1079         this->cameraChanged=\textcolor{keyword}{true};
1080         this->mutex->post();
1081         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1082     \}
1083     \textcolor{keywordflow}{else}
1084         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1085 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!estimate\+Essential@{estimate\+Essential}}
\index{estimate\+Essential@{estimate\+Essential}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{estimate\+Essential()}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::estimate\+Essential (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ab2eded08bca185ac22cd6343cb4c85c8}


It estimates the essential matrix (3x3) E between two views. 

The output is stored in the private member E. 

Definition at line 885 of file stereo\+Camera.\+cpp.



References Ffrom\+P().


\begin{DoxyCode}
886 \{
887     this->InliersL.clear();
888     this->InliersR.clear();
889 
890     \textcolor{keywordflow}{if} (this->PointsL.size()<10 || this->PointsL.size()<10 )
891     \{
892         cout << \textcolor{stringliteral}{"Not enough matches in memory! Run findMatch first!"} << endl;
893         this->E=Mat(3,3,CV\_64FC1);
894         \textcolor{keywordflow}{return};
895     \}
896 
897     updateExpectedCameraMatrices();
898     Mat F\_exp=FfromP(Pleft\_exp,Pright\_exp);
899 
900     vector<Point2f> filteredL;
901     vector<Point2f> filteredR;
902 
903     fprintf(stdout,\textcolor{stringliteral}{"%lu Match Found \(\backslash\)n"},PointsR.size());
904     Mat pl=Mat(3,1,CV\_64FC1);
905     Mat pr=Mat(3,1,CV\_64FC1);
906 
907     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<(int) PointsL.size(); i++)
908     \{
909         pl.at<\textcolor{keywordtype}{double}>(0,0)=PointsL[i].x;
910         pl.at<\textcolor{keywordtype}{double}>(1,0)=PointsL[i].y;
911         pl.at<\textcolor{keywordtype}{double}>(2,0)=1;
912         
913         pr.at<\textcolor{keywordtype}{double}>(0,0)=PointsR[i].x;
914         pr.at<\textcolor{keywordtype}{double}>(1,0)=PointsR[i].y;
915         pr.at<\textcolor{keywordtype}{double}>(2,0)=1;
916              
917         Mat xrFxl=pr.t()*F\_exp*pl;
918         Mat Fxl=F\_exp*pl;
919         Mat Fxr=F\_exp.t()*pr;
920 
921         pow(xrFxl,2,xrFxl);
922 
923         pow(Fxl,2,Fxl);
924 
925         pow(Fxr,2,Fxr);
926         
927         Scalar den1,den2;
928         den1=sum(Fxl);
929         den2=sum(Fxr);
930         \textcolor{keywordtype}{double} sampsonDistance=xrFxl.at<\textcolor{keywordtype}{double}>(0,0)/(den1.val[0]+den2.val[0]);
931         
932         \textcolor{keywordflow}{if} (sampsonDistance<0.1)
933         \{
934             filteredL.push\_back(PointsL[i]);
935             filteredR.push\_back(PointsR[i]);
936         \}
937     \}
938 
939     fprintf(stdout,\textcolor{stringliteral}{"%lu Match After Kinematics Filtering \(\backslash\)n"},filteredL.size());
940 
941     vector<uchar> status;
942     this->F=findFundamentalMat(Mat(filteredL), Mat(filteredR),status, CV\_FM\_8POINT, 1, 0.999);
943     
944     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<(int) filteredL.size(); i++)
945     \{
946         pl.at<\textcolor{keywordtype}{double}>(0,0)=filteredL[i].x;
947         pl.at<\textcolor{keywordtype}{double}>(1,0)=filteredL[i].y;
948         pl.at<\textcolor{keywordtype}{double}>(2,0)=1;
949         
950         pr.at<\textcolor{keywordtype}{double}>(0,0)=filteredR[i].x;
951         pr.at<\textcolor{keywordtype}{double}>(1,0)=filteredR[i].y;
952         pr.at<\textcolor{keywordtype}{double}>(2,0)=1;
953              
954         Mat xrFxl=pr.t()*F*pl;
955         Mat Fxl=F*pl;
956         Mat Fxr=F.t()*pr;
957 
958         pow(xrFxl,2,xrFxl);
959         pow(Fxl,2,Fxl);
960         pow(Fxr,2,Fxr);
961         
962         Scalar den1,den2;
963         den1=sum(Fxl);
964         den2=sum(Fxr);
965         \textcolor{keywordtype}{double} sampsonDistance=xrFxl.at<\textcolor{keywordtype}{double}>(0,0)/(den1.val[0]+den2.val[0]);
966 
967         \textcolor{keywordflow}{if} (status[i]==1 && xrFxl.at<\textcolor{keywordtype}{double}>(0,0)<0.001) 
968         \{
969             InliersL.push\_back(filteredL[i]);
970             InliersR.push\_back(filteredR[i]);
971         \}
972     \}
973 
974     fprintf(stdout,\textcolor{stringliteral}{"%lu Match After RANSAC Filtering \(\backslash\)n"},InliersL.size());
975 
976     \textcolor{keywordflow}{if} (this->InliersL.size()<10 || this->InliersR.size()<10 )
977     \{
978         InliersL.clear();
979         InliersR.clear();
980         cout << \textcolor{stringliteral}{"Not enough matches in memory! Run findMatch first!"} << endl;
981         this->E=Mat(3,3,CV\_64FC1);
982         \textcolor{keywordflow}{return};
983     \}    
984    
985     this->F=findFundamentalMat(Mat(InliersL), Mat(InliersR),status, CV\_FM\_8POINT, 1, 0.999);
986     this->E=this->Kright.t()*this->F*this->Kleft;
987 
988 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!Ffrom\+P@{Ffrom\+P}}
\index{Ffrom\+P@{Ffrom\+P}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Ffrom\+P(\+Mat \&\+P1, Mat \&\+P2)}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::\+Ffrom\+P (
\begin{DoxyParamCaption}
\item[{Mat \&}]{P1, }
\item[{Mat \&}]{P2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3fe4e87322f8644cd21ce06e8522c815}


The function computes the fundamental matrix starting from known camera matrices. 


\begin{DoxyParams}{Parameters}
{\em P1} & a 3x4 matrix representing the camera matrix of the left view. \\
\hline
{\em P2} & a 3x4 matrix representing the camera matrix of the right view. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3x3 matrix representing the fundamental matrix. 
\end{DoxyReturn}


Definition at line 803 of file stereo\+Camera.\+cpp.



Referenced by estimate\+Essential().


\begin{DoxyCode}
804 \{
805     Mat F\_true(3,3,CV\_64FC1);
806 
807     Mat X1(2,4,CV\_64FC1);
808     Mat X2(2,4,CV\_64FC1);
809     Mat X3(2,4,CV\_64FC1);
810 
811     Mat Y1(2,4,CV\_64FC1);
812     Mat Y2(2,4,CV\_64FC1);
813     Mat Y3(2,4,CV\_64FC1);
814     
815 
816     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<P1.rows; i++)
817     \{
818         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<P1.cols; j++)
819         \{
820             \textcolor{keywordflow}{if}(i==0)
821             \{
822                 X2.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
823                 X3.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
824                 Y2.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
825                 Y3.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);                    
826             \}
827             \textcolor{keywordflow}{if}(i==1)
828             \{
829                 X1.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
830                 X3.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
831                 Y1.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
832                 Y3.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);                   
833             \}
834 
835             \textcolor{keywordflow}{if}(i==2)
836             \{
837                 X1.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
838                 X2.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
839                 Y1.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
840                 Y2.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
841 
842             \}
843 
844         \}
845     \}
846 
847 
848 
849     std::vector<Mat> MatX;
850     std::vector<Mat> MatY;
851 
852     MatX.push\_back(X1);
853     MatX.push\_back(X2);
854     MatX.push\_back(X3);
855 
856     MatY.push\_back(Y1);
857     MatY.push\_back(Y2);
858     MatY.push\_back(Y3);
859 
860 
861 
862     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<F\_true.rows; i++)
863     \{
864         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<F\_true.cols; j++)
865         \{
866             Mat X=MatX[i];
867             Mat Y=MatY[j];
868 
869             Mat concatenated;
870 
871             cv::vconcat(X,Y,concatenated);
872 
873             F\_true.at<\textcolor{keywordtype}{double}>(j,i)=cv::determinant(concatenated);
874 
875 
876         \}
877 
878     \}
879 
880 
881     \textcolor{keywordflow}{return} F\_true;
882 
883 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!find\+Match@{find\+Match}}
\index{find\+Match@{find\+Match}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{find\+Match(bool visualize=false, double displacement=20.\+0, double radius=200.\+0)}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::find\+Match (
\begin{DoxyParamCaption}
\item[{bool}]{visualize = {\ttfamily false}, }
\item[{double}]{displacement = {\ttfamily 20.0}, }
\item[{double}]{radius = {\ttfamily 200.0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}


It finds matches between two images. 

S\+I\+F\+T detector and descriptor is used. \begin{DoxyNote}{Note}
Run set\+Images and indistort\+Images methods before using this method. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em visualize} & true if you want to visualize matches between images \\
\hline
{\em displacement} & maximum pixel displacement between first and second camera \\
\hline
{\em radius} & maximum radius between the first candidate match and the second one \\
\hline
\end{DoxyParams}


Definition at line 675 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
676 \{
677     \textcolor{keywordflow}{if} (this->imleftund.empty() || this->imrightund.empty())
678     \{
679         imleftund=imleft;
680         imrightund=imright;
681     \}
682 
683     this->PointsL.clear();
684     this->PointsR.clear();
685     
686     this->InliersL.clear();
687     this->InliersR.clear();
688 
689     Mat grayleft(imleftund.rows,imleftund.cols, CV\_8UC1);
690     imleftund.convertTo(grayleft,CV\_8UC1);
691     
692     Mat grayright(imrightund.rows,imrightund.cols,CV\_8UC1);
693     imrightund.convertTo(grayright,CV\_8UC1);
694     
695     vector<KeyPoint> keypoints1,keypoints2;
696     Mat descriptors1,descriptors2;
697 
698     Ptr<cv::FeatureDetector> detector=cv::FeatureDetector::create(\textcolor{stringliteral}{"SIFT"});
699     Ptr<cv::DescriptorExtractor> descriptorExtractor=cv::DescriptorExtractor::create(\textcolor{stringliteral}{"SIFT"});
700     cv::BFMatcher descriptorMatcher;
701 
702     yAssert(detector!=NULL);
703     yAssert(descriptorExtractor!=NULL);
704 
705     detector->detect(grayleft,keypoints1);
706     descriptorExtractor->compute(grayleft,keypoints1,descriptors1);
707 
708     detector->detect(grayright,keypoints2);
709     descriptorExtractor->compute(grayright,keypoints2,descriptors2);
710 
711     vector<DMatch> filteredMatches;
712     crossCheckMatching(descriptorMatcher,descriptors1,descriptors2,filteredMatches,radius);
713 
714     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<filteredMatches.size(); i++)
715     \{
716         Point2f pointL=keypoints1[filteredMatches[i].queryIdx].pt;
717         Point2f pointR=keypoints2[filteredMatches[i].trainIdx].pt;
718         \textcolor{keywordflow}{if} (fabs(pointL.y-pointR.y)<displacement)
719         \{
720             this->PointsR.push\_back(pointR);
721             this->PointsL.push\_back(pointL);
722         \}   
723     \}
724 
725     Mat matchImg;
726     \textcolor{keywordflow}{if} (visualize)
727         cv::drawMatches(this->imleftund,keypoints1,this->imrightund,keypoints2,
728                         filteredMatches,matchImg,Scalar(0,0,255,0),Scalar(0,0,255,0));
729 
730     \textcolor{keywordflow}{return} matchImg;
731 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!from\+Rectified\+To\+Original@{from\+Rectified\+To\+Original}}
\index{from\+Rectified\+To\+Original@{from\+Rectified\+To\+Original}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{from\+Rectified\+To\+Original(int u, int v, int camera)}]{\setlength{\rightskip}{0pt plus 5cm}Point2f Stereo\+Camera\+::from\+Rectified\+To\+Original (
\begin{DoxyParamCaption}
\item[{int}]{u, }
\item[{int}]{v, }
\item[{int}]{camera}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3d8fde0cbd4604085b883f22cc606c01}


Given the u,v pixel coordinates in the rectified image the method returns the position of the pixel in the non-\/rectified frame. 


\begin{DoxyParams}{Parameters}
{\em u} & the x pixel coordinate in the rectified image. \\
\hline
{\em v} & the y pixel coordinate in the rectified image. \\
\hline
{\em cam} & cam=1 for left image, cam=2 for right image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pixel position in the non-\/rectified image. 
\end{DoxyReturn}


Definition at line 647 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
648 \{
649     cv::Point2f originalPoint;
650 
651 
652     \textcolor{keywordflow}{if}(u>=map11.rows || u<0 || v>=map12.cols || v< 0)
653     \{
654         originalPoint.x=0;
655         originalPoint.y=0;
656         \textcolor{keywordflow}{return} originalPoint;
657     \}
658     \textcolor{keywordflow}{if}(camera==LEFT)
659     \{
660             originalPoint.x=map11.ptr<\textcolor{keywordtype}{float}>(v)[u];
661             originalPoint.y=map12.ptr<\textcolor{keywordtype}{float}>(v)[u];
662     \}
663     \textcolor{keywordflow}{else}
664     \{
665             originalPoint.x=map21.ptr<\textcolor{keywordtype}{float}>(v)[u];
666             originalPoint.y=map22.ptr<\textcolor{keywordtype}{float}>(v)[u];
667     \}
668 
669 
670     \textcolor{keywordflow}{return} originalPoint;
671 
672 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Disparity@{get\+Disparity}}
\index{get\+Disparity@{get\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Disparity() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Disparity (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a7e9dc528c0a2b8d587fbe80738063a34}


It returns the disparity image. 

\begin{DoxyReturn}{Returns}
the disparity image computed via \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity()}. The image is 8 bit unsigned. 
\end{DoxyReturn}


Definition at line 471 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
471                                      \{
472     \textcolor{keywordflow}{return} this->Disparity;
473 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Disparity16@{get\+Disparity16}}
\index{get\+Disparity16@{get\+Disparity16}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Disparity16() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Disparity16 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_af77824b3c5785cac11e585ef698c2537}


It returns the disparity image. 

\begin{DoxyReturn}{Returns}
the disparity image computed via \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity()}. The image is 16 bit signed. 
\end{DoxyReturn}


Definition at line 475 of file stereo\+Camera.\+cpp.



Referenced by metric\+Triangulation().


\begin{DoxyCode}
475                                        \{
476     \textcolor{keywordflow}{return} this->Disparity16;
477 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Dist\+Coeff\+Left@{get\+Dist\+Coeff\+Left}}
\index{get\+Dist\+Coeff\+Left@{get\+Dist\+Coeff\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Dist\+Coeff\+Left()}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Dist\+Coeff\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a4830201154ab288bd93f6cceb2c2daf5}


It returns the 5x1 left distortion coefficients. 

\begin{DoxyReturn}{Returns}
5x1 left distortion coefficients. 
\end{DoxyReturn}


Definition at line 2237 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2238 \{
2239     \textcolor{keywordflow}{return} this->DistL;
2240 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Dist\+Coeff\+Right@{get\+Dist\+Coeff\+Right}}
\index{get\+Dist\+Coeff\+Right@{get\+Dist\+Coeff\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Dist\+Coeff\+Right()}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Dist\+Coeff\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3edeb24b68ee4266f89982533ad1e9bf}


It returns the 5x1 right distortion coefficients. 

\begin{DoxyReturn}{Returns}
5x1 right distortion coefficients. 
\end{DoxyReturn}


Definition at line 2242 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2243 \{
2244     \textcolor{keywordflow}{return} this->DistR;
2245 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Distorted\+Pixel@{get\+Distorted\+Pixel}}
\index{get\+Distorted\+Pixel@{get\+Distorted\+Pixel}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Distorted\+Pixel(int u, int v, int cam=1)}]{\setlength{\rightskip}{0pt plus 5cm}Point2f Stereo\+Camera\+::get\+Distorted\+Pixel (
\begin{DoxyParamCaption}
\item[{int}]{u, }
\item[{int}]{v, }
\item[{int}]{cam = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_af64550bb8a7a665930dee5eea87b7e47}


Given the u,v pixel coordinates in the undistorted image the method returns the original position of the pixel in the distorted frame. 


\begin{DoxyParams}{Parameters}
{\em u} & the x pixel coordinate in the undistorted image. \\
\hline
{\em v} & the y pixel coordinate in the undistorted image. \\
\hline
{\em cam} & cam=1 for left image, cam=2 for right image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pixel position in the distorted image. 
\end{DoxyReturn}


Definition at line 2256 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2257 \{
2258     Point2f distortedPixel;
2259     Mat MapperX,MapperY;
2260 
2261     \textcolor{keywordflow}{if}(cam==LEFT)
2262     \{
2263         MapperX=mapxL;
2264         MapperY=mapyL;
2265     \}
2266     \textcolor{keywordflow}{else}
2267     \{
2268         MapperX=mapxR;
2269         MapperY=mapyR;
2270     \}
2271     distortedPixel.x=MapperX.ptr<\textcolor{keywordtype}{float}>(v)[u];
2272     distortedPixel.y=MapperY.ptr<\textcolor{keywordtype}{float}>(v)[u];
2273 
2274     \textcolor{keywordflow}{return} distortedPixel;
2275 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Fundamental@{get\+Fundamental}}
\index{get\+Fundamental@{get\+Fundamental}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Fundamental() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Fundamental (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a57235f5bf074b5cd96d75d0d1662c26c}


It returns the 3x3 fundamental matrix. 

\begin{DoxyReturn}{Returns}
3x3 fundamental matrix. 
\end{DoxyReturn}


Definition at line 1440 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1440                                        \{
1441     \textcolor{keywordflow}{return} this->F;
1442 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Left@{get\+Im\+Left}}
\index{get\+Im\+Left@{get\+Im\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Left() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Im\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a1ed40435ff66e171885c8b2be6987ef7}


It returns the left (first) image. 

\begin{DoxyReturn}{Returns}
the left (first) image. 
\end{DoxyReturn}


Definition at line 463 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
463                                   \{
464     \textcolor{keywordflow}{return} this->imleft;
465 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Left\+Und@{get\+Im\+Left\+Und}}
\index{get\+Im\+Left\+Und@{get\+Im\+Left\+Und}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Left\+Und() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Im\+Left\+Und (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a8beef7e6d56b98f531ceeb2ed6778c28}


It returns the left undistorted image. 

\begin{DoxyReturn}{Returns}
the left undistorted image. 
\end{DoxyReturn}


Definition at line 1436 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1436                                      \{
1437     \textcolor{keywordflow}{return} this->imleftund;
1438 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Right@{get\+Im\+Right}}
\index{get\+Im\+Right@{get\+Im\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Right() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Im\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_ade2fcf87e8afab6cf836b979fd048110}


It returns the right (second) image. 

\begin{DoxyReturn}{Returns}
the right (second) image. 
\end{DoxyReturn}


Definition at line 467 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
467                                    \{
468     \textcolor{keywordflow}{return} this->imright;
469 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Right\+Und@{get\+Im\+Right\+Und}}
\index{get\+Im\+Right\+Und@{get\+Im\+Right\+Und}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Right\+Und() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Im\+Right\+Und (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a915c0da2c83bca6776152e8d0205e9d1}


It returns the right undistorted image. 

\begin{DoxyReturn}{Returns}
the right undistorted image. 
\end{DoxyReturn}


Definition at line 1444 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1444                                       \{
1445     \textcolor{keywordflow}{return} this->imrightund;
1446 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Kleft@{get\+Kleft}}
\index{get\+Kleft@{get\+Kleft}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Kleft() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Kleft (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_aef0ec58b3e5cf02f7b925340c57ee477}


It returns the 3x3 left camera matrix. 

\begin{DoxyReturn}{Returns}
3x3 left camera matrix. 
\end{DoxyReturn}


Definition at line 42 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
42                                  \{
43     \textcolor{keywordflow}{return} this->Kleft;
44 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Kright@{get\+Kright}}
\index{get\+Kright@{get\+Kright}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Kright() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Kright (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a6c2d8ae33c7e8f1e8e4d6f38ffe65b94}


It returns the 3x3 right camera matrix. 

\begin{DoxyReturn}{Returns}
3x3 right camera matrix. 
\end{DoxyReturn}


Definition at line 46 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
46                                   \{
47     \textcolor{keywordflow}{return} this->Kright;
48 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+L\+Rectified@{get\+L\+Rectified}}
\index{get\+L\+Rectified@{get\+L\+Rectified}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+L\+Rectified()}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+L\+Rectified (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a0bd4492f7f87862955da0bc5d0042cc8}


The method returns the first rectified image. 

\begin{DoxyReturn}{Returns}
The first rectified image. 
\end{DoxyReturn}


Definition at line 2115 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2116 \{
2117     \textcolor{keywordflow}{return} this->imgLeftRect;
2118 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Mapper\+L@{get\+Mapper\+L}}
\index{get\+Mapper\+L@{get\+Mapper\+L}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Mapper\+L() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Mapper\+L (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_aa1b2b60fa8d72cb8928e8db58842e65f}


It returns the mapping between the original left camera and the rectified left camera. 

\begin{DoxyReturn}{Returns}
a 16 bit signed 2 channel image containing the mapping from the original left camera to the rectified left camera. 
\end{DoxyReturn}


Definition at line 1849 of file stereo\+Camera.\+cpp.



Referenced by metric\+Triangulation().


\begin{DoxyCode}
1849                                    \{
1850     \textcolor{keywordflow}{return} this->MapperL;
1851 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Mapper\+R@{get\+Mapper\+R}}
\index{get\+Mapper\+R@{get\+Mapper\+R}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Mapper\+R() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Mapper\+R (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_aceec69a43430b8445e66e907a179e57e}


It returns the mapping between the original right camera and the rectified right camera. 

\begin{DoxyReturn}{Returns}
a 16 bit signed 2 channel image containing the mapping from the original right camera to the rectified right camera. 
\end{DoxyReturn}


Definition at line 1853 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1853                                    \{
1854     \textcolor{keywordflow}{return} this->MapperR;
1855 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Match\+Left@{get\+Match\+Left}}
\index{get\+Match\+Left@{get\+Match\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Match\+Left() const }]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ Point2f $>$ Stereo\+Camera\+::get\+Match\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a42908347f3f8457e4569a9e6b7e19118}


It returns the pixel coordinates of the matches in the left image. 

\begin{DoxyReturn}{Returns}
pixel coordinates of the matches in the left image. 
\end{DoxyReturn}


Definition at line 50 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
50                                                  \{
51     \textcolor{keywordflow}{return} this->InliersL;
52 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Match\+Right@{get\+Match\+Right}}
\index{get\+Match\+Right@{get\+Match\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Match\+Right() const }]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ Point2f $>$ Stereo\+Camera\+::get\+Match\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a24e61743d392be57d4d2e5b88e55abd1}


It returns the pixel coordinates of the matches in the right image. 

\begin{DoxyReturn}{Returns}
pixel coordinates of the matches in the right image. 
\end{DoxyReturn}


Definition at line 54 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
54                                                   \{
55     \textcolor{keywordflow}{return} this->InliersR;
56 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Q@{get\+Q}}
\index{get\+Q@{get\+Q}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Q() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Q (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a7de1dc2bd3416e4d9dcb4f6a373297b5}


It returns the 4x4 disparity-\/to-\/depth mapping matrix. 

\begin{DoxyReturn}{Returns}
4x4 disparity-\/to-\/depth mapping matrix. 
\end{DoxyReturn}


Definition at line 479 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
479                              \{
480     \textcolor{keywordflow}{return} this->Q;
481 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Lrect@{get\+R\+Lrect}}
\index{get\+R\+Lrect@{get\+R\+Lrect}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+R\+Lrect() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+R\+Lrect (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_ae3421ead8d31c84c726a27e3b702d798}


It returns the rotation matrix between the original left camera and the rectified left camera. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the original left camera and the rectified left camera. 
\end{DoxyReturn}


Definition at line 1841 of file stereo\+Camera.\+cpp.



Referenced by compute\+World\+Image(), metric\+Triangulation(), and triangulate\+Known\+Disparity().


\begin{DoxyCode}
1841                                   \{
1842     \textcolor{keywordflow}{return} this->RLrect;
1843 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Rotation@{get\+Rotation}}
\index{get\+Rotation@{get\+Rotation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Rotation() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Rotation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a2baf8c2d797f2ae0d7d00d8e41250db0}


It returns the rotation matrix between the two cameras. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the first and the second camera. 
\end{DoxyReturn}


Definition at line 1536 of file stereo\+Camera.\+cpp.



Referenced by horn().


\begin{DoxyCode}
1536                                     \{
1537     \textcolor{keywordflow}{return} this->R;
1538 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Rectified@{get\+R\+Rectified}}
\index{get\+R\+Rectified@{get\+R\+Rectified}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+R\+Rectified()}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+R\+Rectified (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_aaf4ba8eaa338ff24db1196849a96e5e9}


The method returns the second rectified image. 

\begin{DoxyReturn}{Returns}
The second rectified image. 
\end{DoxyReturn}


Definition at line 2120 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2121 \{
2122     \textcolor{keywordflow}{return} this->imgRightRect;
2123 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Rrect@{get\+R\+Rrect}}
\index{get\+R\+Rrect@{get\+R\+Rrect}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+R\+Rrect() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+R\+Rrect (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_a41eb4d6884d233cf9b1a3cdc226f7028}


It returns the rotation matrix between the original right camera and the rectified right camera. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the original right camera and the rectified right camera. 
\end{DoxyReturn}


Definition at line 1845 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1845                                   \{
1846     \textcolor{keywordflow}{return} this->RRrect;
1847 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Translation@{get\+Translation}}
\index{get\+Translation@{get\+Translation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Translation() const }]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Translation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classStereoCamera_ae914424daf5b615dea6d7d09921f0b19}


It returns the translation vector between the two cameras. 

\begin{DoxyReturn}{Returns}
3x1 translation matrix between the first and the second camera. 
\end{DoxyReturn}


Definition at line 1532 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1532                                        \{
1533     \textcolor{keywordflow}{return} this->T;
1534 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!horn@{horn}}
\index{horn@{horn}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{horn(\+Mat \&\+K1, Mat \&\+K2, vector$<$ Point2f $>$ \&\+Points1, vector$<$ Point2f $>$ \&\+Points2, Mat \&\+Rot, Mat \&\+Tras)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::horn (
\begin{DoxyParamCaption}
\item[{Mat \&}]{K1, }
\item[{Mat \&}]{K2, }
\item[{vector$<$ Point2f $>$ \&}]{Points1, }
\item[{vector$<$ Point2f $>$ \&}]{Points2, }
\item[{Mat \&}]{Rot, }
\item[{Mat \&}]{Tras}
\end{DoxyParamCaption}
)}\label{classStereoCamera_adf155975709fdbf09d3133899d074a02}


It performs the horn relative orientations algorithm i.\+e. 

it estimates the motion from one camera to another one using a initial guess. A good initial guess can be obtained using the essential\+Decomposition method. 
\begin{DoxyParams}{Parameters}
{\em K1} & 3x3 matrix with intrinsic parameters of the first camera \\
\hline
{\em K2} & 3x3 matrix with intrinsic parameters of the second camera \\
\hline
{\em Points1} & matches in the first image \\
\hline
{\em Points2} & matches in the second image \\
\hline
{\em Rot} & initial rotation (3x3 matrix) guess. The new output rotation is stored here \\
\hline
{\em Tras} & initial translation (3x1 matrix) guess. The new output translation is stored here \\
\hline
\end{DoxyParams}


Definition at line 1636 of file stereo\+Camera.\+cpp.



References get\+Rotation().



Referenced by horn\+Relative\+Orientations().


\begin{DoxyCode}
1636                                                                                                            
              \{
1637     \textcolor{keywordtype}{double} prevres = 1E40;
1638     \textcolor{keywordtype}{double} res = 1E39;
1639     \textcolor{keywordtype}{double} vanishing = 1E-16;
1640     Tras=Tras/norm(Tras);
1641 
1642     normalizePoints(K1,K2,PointsL,PointsR);
1643     \textcolor{keywordtype}{int} iters=0;
1644     Mat B(3,3,CV\_64FC1);
1645     Mat C(3,3,CV\_64FC1);
1646     Mat D(3,3,CV\_64FC1);
1647     Mat cs(3,1,CV\_64FC1);
1648     Mat ds(3,1,CV\_64FC1);
1649     Mat r1(3,1,CV\_64FC1);
1650     Mat r2(3,1,CV\_64FC1);
1651 
1652     \textcolor{keywordflow}{while} ( (prevres  - res  >  vanishing) ) \{
1653         iters = iters+1;
1654         
1655         B.setTo(0);
1656         C.setTo(0);
1657         D.setTo(0);
1658         cs.setTo(0);
1659         ds.setTo(0);
1660        
1661         prevres=res;
1662         res=0;
1663         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<(int) PointsL.size(); i++) \{
1664             
1665             r1.at<\textcolor{keywordtype}{double}>(0,0)=PointsL[i].x;
1666             r1.at<\textcolor{keywordtype}{double}>(1,0)=PointsL[i].y;
1667             r1.at<\textcolor{keywordtype}{double}>(2,0)=1;
1668             r1=r1/norm(r1);
1669 
1670             r2.at<\textcolor{keywordtype}{double}>(0,0)=PointsR[i].x;
1671             r2.at<\textcolor{keywordtype}{double}>(1,0)=PointsR[i].y;
1672             r2.at<\textcolor{keywordtype}{double}>(2,0)=1;
1673             r2=r2/norm(r2);
1674 
1675 
1676             Mat r1p= Rot*r1;
1677 
1678             Mat ci=r1p.cross(r2);
1679             Mat di=r1p.cross(r2.cross(Tras));
1680             Mat si=Tras.t()*ci;
1681 
1682           
1683             B=B+(ci*di.t());
1684             D=D+(di*di.t());
1685             C=C+(ci*ci.t());
1686             
1687             cs=cs+ (si.at<\textcolor{keywordtype}{double}>(0,0)*ci);
1688             ds=ds+ (si.at<\textcolor{keywordtype}{double}>(0,0)*di);
1689 
1690             Mat residual=Tras.t()*ci*ci.t()*Tras;
1691             res=res+residual.at<\textcolor{keywordtype}{double}>(0,0);
1692 
1693         \}
1694 
1695         Mat L(7,7,CV\_64FC1);
1696         L.setTo(0);
1697         
1698         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1699             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++)
1700                 L.at<\textcolor{keywordtype}{double}>(i,j)=C.at<\textcolor{keywordtype}{double}>(i,j);
1701 
1702         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1703             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1704                 L.at<\textcolor{keywordtype}{double}>(i,j)=B.at<\textcolor{keywordtype}{double}>(i,j-3);
1705     
1706         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1707                 L.at<\textcolor{keywordtype}{double}>(i,6)=Tras.at<\textcolor{keywordtype}{double}>(i,0);
1708 
1709 
1710         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=3; i<6; i++)
1711             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++) \{
1712                 Mat Bt=B.t();
1713                 L.at<\textcolor{keywordtype}{double}>(i,j)=Bt.at<\textcolor{keywordtype}{double}>(i-3,j);
1714 
1715             \}
1716 
1717 
1718         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=3; i<6; i++)
1719             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1720                 L.at<\textcolor{keywordtype}{double}>(i,j)=D.at<\textcolor{keywordtype}{double}>(i-3,j-3);
1721 
1722         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++) \{
1723                 Mat Trast=Tras.t();
1724                 L.at<\textcolor{keywordtype}{double}>(6,j)=Trast.at<\textcolor{keywordtype}{double}>(0,j);
1725         \}
1726 
1727 
1728         Mat Y(7,1,CV\_64FC1);
1729         Y.setTo(0);
1730 
1731         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++)
1732                 Y.at<\textcolor{keywordtype}{double}>(j,0)=-cs.at<\textcolor{keywordtype}{double}>(j,0);
1733 
1734         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1735                 Y.at<\textcolor{keywordtype}{double}>(j,0)=-ds.at<\textcolor{keywordtype}{double}>(j-3,0);
1736 
1737         Mat Linv=L.inv();
1738         Mat result=Linv*Y;
1739         Tras=Tras+result(Range(0,3),Range(0,1));
1740         Tras=Tras/norm(Tras);
1741 
1742         Mat q(4,1,CV\_64FC1);
1743 
1744         Mat temp=result(Range(3,6),Range(0,1));       
1745         q.at<\textcolor{keywordtype}{double}>(0,0)= sqrt(1-(0.25* norm(temp)*norm(temp)));
1746         q.at<\textcolor{keywordtype}{double}>(1,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(3,0);
1747         q.at<\textcolor{keywordtype}{double}>(2,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(4,0);
1748         q.at<\textcolor{keywordtype}{double}>(3,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(5,0);
1749 
1750 
1751         Mat deltaR(3,3,CV\_64FC1);
1752         getRotation(q,deltaR);
1753 
1754         Rot=deltaR*Rot;
1755 
1756         SVD dec(Rot);
1757 
1758         Mat Id = Mat::eye(3, 3, CV\_64F);
1759 
1760         Mat Vt=dec.vt;
1761         Mat U=dec.u;
1762 
1763         Rot=U*Id*Vt;
1764     \}
1765 
1766 
1767 
1768 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!horn\+Relative\+Orientations@{horn\+Relative\+Orientations}}
\index{horn\+Relative\+Orientations@{horn\+Relative\+Orientations}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{horn\+Relative\+Orientations()}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::horn\+Relative\+Orientations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a36dae897d07544e8faca8c90216173a6}


It performs the horn relative orientations, all the parameters are assumed initialized in the \hyperlink{classStereoCamera}{Stereo\+Camera} object. 

The new output Rotation and Translation matrices are stored in the R and T members. 

Definition at line 1575 of file stereo\+Camera.\+cpp.



References horn().


\begin{DoxyCode}
1575                                             \{
1576 
1577     \textcolor{keywordflow}{if}(this->PointsL.size()<10 || this->PointsR.size()<10) \{
1578         cout << \textcolor{stringliteral}{"No matches found! Run findMatch fist!"} << endl;
1579         \textcolor{keywordflow}{return};
1580     \}
1581 
1582 
1583     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->Kright.empty() || this->R.empty() || this->T.empty()) \{
1584         cout << \textcolor{stringliteral}{"Cameras are empty, run Calibration first"} << endl;
1585         \textcolor{keywordflow}{return};
1586     \}
1587 
1588     \textcolor{keywordflow}{if}(InliersL.empty()) \{
1589         InliersL=PointsL;
1590         InliersR=PointsR;
1591     \}
1592 
1593     Mat Rot=this->R.clone();
1594     Mat Tras=this->T.clone();
1595     horn(this->Kleft,this->Kright,this->InliersL,this->InliersR,Rot,Tras);
1596 
1597 
1598     this->R=Rot.clone();
1599     this->Rinit=Rot.clone();
1600 
1601     this->T=Tras/norm(Tras)*norm(T);
1602     this->Tinit=Tras/norm(Tras)*norm(Tinit);
1603 
1604     this->updatePMatrix();
1605 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!init\+E\+L\+A\+S@{init\+E\+L\+A\+S}}
\index{init\+E\+L\+A\+S@{init\+E\+L\+A\+S}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{init\+E\+L\+A\+S(yarp\+::os\+::\+Resource\+Finder \&rf)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::init\+E\+L\+A\+S (
\begin{DoxyParamCaption}
\item[{yarp\+::os\+::\+Resource\+Finder \&}]{rf}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a067e1e94a48cb390491fea0f6748dda8}


Initialization of E\+L\+A\+S parameters. 


\begin{DoxyParams}{Parameters}
{\em rf} & The Resource\+Finder mechanism is used to set the parameters either to the default value or to the value passed by the user via command line. See the documentation of the \hyperlink{group__SFM}{S\+F\+M} module to get the list of parameters that are processed by this initialization function. \\
\hline
\end{DoxyParams}


Definition at line 112 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
113 \{
114     use\_elas = \textcolor{keyword}{true};
115 
116     \textcolor{keywordtype}{string} elas\_string = rf.check(\textcolor{stringliteral}{"elas\_setting"},Value(\textcolor{stringliteral}{"ROBOTICS"})).asString().c\_str();
117 
118     \textcolor{keywordtype}{double} disp\_scaling\_factor = rf.check(\textcolor{stringliteral}{"disp\_scaling\_factor"},Value(1.0)).asDouble();
119 
120     elaswrap = \textcolor{keyword}{new} elasWrapper(disp\_scaling\_factor, elas\_string);
121 
122     
123     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_subsampling"}))
124         elaswrap->set\_subsampling(\textcolor{keyword}{true});
125 
126     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_add\_corners"}))
127         elaswrap->set\_add\_corners(\textcolor{keyword}{true});
128 
129 
130     elaswrap->set\_ipol\_gap\_width(40);
131     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_ipol\_gap\_width"}))
132         elaswrap->set\_ipol\_gap\_width(rf.find(\textcolor{stringliteral}{"elas\_ipol\_gap\_width"}).asInt());
133 
134 
135     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_support\_threshold"}))
136         elaswrap->set\_support\_threshold(rf.find(\textcolor{stringliteral}{"elas\_support\_threshold"}).asDouble());
137 
138     \textcolor{keywordflow}{if}(rf.check(\textcolor{stringliteral}{"elas\_gamma"}))
139         elaswrap->set\_gamma(rf.find(\textcolor{stringliteral}{"elas\_gamma"}).asDouble());
140 
141     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_sradius"}))
142         elaswrap->set\_sradius(rf.find(\textcolor{stringliteral}{"elas\_sradius"}).asDouble());
143 
144     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_match\_texture"}))
145         elaswrap->set\_match\_texture(rf.find(\textcolor{stringliteral}{"elas\_match\_texture"}).asInt());
146 
147     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_filter\_median"}))
148         elaswrap->set\_filter\_median(rf.find(\textcolor{stringliteral}{"elas\_filter\_median"}).asBool());
149 
150     \textcolor{keywordflow}{if} (rf.check(\textcolor{stringliteral}{"elas\_filter\_adaptive\_mean"}))
151         elaswrap->set\_filter\_adaptive\_mean(rf.find(\textcolor{stringliteral}{"elas\_filter\_adaptive\_mean"}).asBool());
152 
153 
154     cout << endl << \textcolor{stringliteral}{"ELAS parameters:"} << endl << endl;
155 
156     cout << \textcolor{stringliteral}{"disp\_scaling\_factor: "} << disp\_scaling\_factor << endl;
157 
158     cout << \textcolor{stringliteral}{"setting: "} << elas\_string << endl;
159 
160     cout << \textcolor{stringliteral}{"postprocess\_only\_left: "} << elaswrap->get\_postprocess\_only\_left() << endl;
161     cout << \textcolor{stringliteral}{"subsampling: "} << elaswrap->get\_subsampling() << endl;
162 
163     cout << \textcolor{stringliteral}{"add\_corners: "} << elaswrap->get\_add\_corners() << endl;
164 
165     cout << \textcolor{stringliteral}{"ipol\_gap\_width: "} << elaswrap->get\_ipol\_gap\_width() << endl;
166 
167     cout << \textcolor{stringliteral}{"support\_threshold: "} << elaswrap->get\_support\_threshold() << endl;
168     cout << \textcolor{stringliteral}{"gamma: "} << elaswrap->get\_gamma() << endl;
169     cout << \textcolor{stringliteral}{"sradius: "} << elaswrap->get\_sradius() << endl;
170 
171     cout << \textcolor{stringliteral}{"match\_texture: "} << elaswrap->get\_match\_texture() << endl;
172 
173     cout << \textcolor{stringliteral}{"filter\_median: "} << elaswrap->get\_filter\_median() << endl;
174     cout << \textcolor{stringliteral}{"filter\_adaptive\_mean: "} << elaswrap->get\_filter\_adaptive\_mean() << endl;
175 
176     cout << endl;
177 
178 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!metric\+Triangulation@{metric\+Triangulation}}
\index{metric\+Triangulation@{metric\+Triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{metric\+Triangulation(\+Point2f \&point1, double th\+Meters=10)}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::metric\+Triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{double}]{th\+Meters = {\ttfamily 10}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a2fcd3e1767bcf04716b0e2ac76098430}


It performs the metric triangulation given the pixel coordinates on the first image. 

Run compute disparity before using this method. 
\begin{DoxyParams}{Parameters}
{\em point1} & the pixel coordinates in the first image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3\+D point w.\+r.\+t. the first camera reference system. 
\end{DoxyReturn}


Definition at line 1887 of file stereo\+Camera.\+cpp.



References get\+Disparity16(), and get\+Mapper\+L().


\begin{DoxyCode}
1887                                                                           \{
1888     mutex->wait();
1889 
1890     \textcolor{keywordflow}{if}(Q.empty() || Disparity16.empty()) \{
1891         cout << \textcolor{stringliteral}{"Run computeDisparity() method first!"} << endl;
1892         Point3f point;
1893         point.x=0.0;
1894         point.y=0.0;
1895         point.z=0.0;
1896 
1897         mutex->post();
1898         \textcolor{keywordflow}{return} point;
1899     \}
1900 
1901     \textcolor{keywordtype}{int} u=(int) point1.x; 
1902     \textcolor{keywordtype}{int} v=(\textcolor{keywordtype}{int}) point1.y;
1903     Point3f point;
1904 
1905 
1906     \textcolor{comment}{// Mapping from Rectified Cameras to Original Cameras}
1907     Mat Mapper=this->getMapperL();
1908 
1909     \textcolor{keywordflow}{if}(Mapper.empty()) \{
1910         point.x=0.0;
1911         point.y=0.0;
1912         point.z=0.0;
1913        
1914         mutex->post();
1915         \textcolor{keywordflow}{return} point;
1916     \}
1917 
1918 
1919     \textcolor{keywordtype}{float} usign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u];
1920     \textcolor{keywordtype}{float} vsign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u+1]; 
1921 
1922     u=cvRound(usign);
1923     v=cvRound(vsign);
1924 
1925     IplImage disp16=this->getDisparity16();
1926     
1927 
1928     \textcolor{keywordflow}{if}(u<0 || u>=disp16.width || v<0 || v>=disp16.height) \{
1929         point.x=0.0;
1930         point.y=0.0;
1931         point.z=0.0;
1932         mutex->post();
1933         \textcolor{keywordflow}{return} point;
1934     \}
1935 
1936     CvScalar scal=cvGet2D(&disp16,v,u);
1937     \textcolor{keywordtype}{double} disparity=scal.val[0]/16.0;
1938     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) disparity*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
1939     point.x= (float)((\textcolor{keywordtype}{float}) (usign+1)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
1940     point.y=(float)((\textcolor{keywordtype}{float}) (vsign+1)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
1941     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
1942 
1943     point.x=point.x/w;
1944     point.y=point.y/w;
1945     point.z=point.z/w;
1946 
1947     \textcolor{comment}{// discard points far more than thMeters meters or with not valid disparity (<0)}
1948     \textcolor{keywordflow}{if}(point.z>thMeters || point.z<0) \{
1949         point.x=0.0;
1950         point.y=0.0;
1951         point.z=0.0;
1952     \} 
1953     \textcolor{keywordflow}{else} \{
1954             Mat P(3,1,CV\_64FC1);
1955             P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
1956             P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
1957             P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
1958 
1959             \textcolor{comment}{// Rototranslation from rectified camera to original camera}
1960             P=this->getRLrect().t()*P;
1961 
1962             point.x=(float) P.at<\textcolor{keywordtype}{double}>(0,0);
1963             point.y=(float) P.at<\textcolor{keywordtype}{double}>(1,0);
1964             point.z=(float) P.at<\textcolor{keywordtype}{double}>(2,0);
1965     \}
1966  
1967     mutex->post();
1968     \textcolor{keywordflow}{return} point;
1969 
1970 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!metric\+Triangulation@{metric\+Triangulation}}
\index{metric\+Triangulation@{metric\+Triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{metric\+Triangulation(\+Point2f \&point1, Mat \&\+H, double th\+Meters=10)}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::metric\+Triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Mat \&}]{H, }
\item[{double}]{th\+Meters = {\ttfamily 10}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3cf53fac6336eea107a26bd5cdbbdd03}


It performs the metric triangulation given the pixel coordinates on the first image. 

The 3\+D Point is w.\+r.\+t the system defined by the parameter H. Run compute disparity before using this method. 
\begin{DoxyParams}{Parameters}
{\em point1} & the pixel coordinates in the first image. \\
\hline
{\em H} & the 4x4 rototranslation matrix of the system. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3\+D point w.\+r.\+t. the reference system defined by H. 
\end{DoxyReturn}


Definition at line 1974 of file stereo\+Camera.\+cpp.



References get\+Disparity16(), get\+Mapper\+L(), and get\+R\+Lrect().


\begin{DoxyCode}
1974                                                                                   \{
1975     mutex->wait();
1976 
1977     \textcolor{keywordflow}{if}(H.empty())
1978         H=H.eye(4,4,CV\_64FC1);
1979 
1980     \textcolor{keywordflow}{if}(Q.empty() || Disparity16.empty()) \{
1981         cout << \textcolor{stringliteral}{"Run computeDisparity() method first!"} << endl;
1982         Point3f point;
1983         point.x=0.0;
1984         point.y=0.0;
1985         point.z=0.0;
1986         mutex->post();
1987         \textcolor{keywordflow}{return} point;
1988     \}
1989 
1990     \textcolor{keywordtype}{int} u=(int) point1.x; \textcolor{comment}{// matrix starts from (0,0), pixels from (1,1)}
1991     \textcolor{keywordtype}{int} v=(\textcolor{keywordtype}{int}) point1.y;
1992     Point3f point;
1993 
1994 
1995     \textcolor{comment}{// Mapping from Rectified Cameras to Original Cameras}
1996     Mat Mapper=this->getMapperL();
1997 
1998     \textcolor{keywordflow}{if}(Mapper.empty()) \{
1999         point.x=0.0;
2000         point.y=0.0;
2001         point.z=0.0;
2002         
2003         mutex->post();
2004         \textcolor{keywordflow}{return} point;
2005     \}
2006 
2007 
2008     \textcolor{keywordtype}{float} usign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u];
2009     \textcolor{keywordtype}{float} vsign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u+1]; 
2010 
2011     u=cvRound(usign);
2012     v=cvRound(vsign);
2013 
2014     IplImage disp16=this->getDisparity16();
2015     
2016 
2017     \textcolor{keywordflow}{if}(u<0 || u>=disp16.width || v<0 || v>=disp16.height) \{
2018         point.x=0.0;
2019         point.y=0.0;
2020         point.z=0.0;
2021         mutex->post();
2022         \textcolor{keywordflow}{return} point;
2023     \}
2024 
2025     CvScalar scal=cvGet2D(&disp16,v,u);
2026     \textcolor{keywordtype}{double} disparity=scal.val[0]/16.0;
2027     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) disparity*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
2028     point.x= (float)((\textcolor{keywordtype}{float}) (usign+1)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
2029     point.y=(float)((\textcolor{keywordtype}{float}) (vsign+1)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
2030     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
2031 
2032     point.x=point.x/w;
2033     point.y=point.y/w;
2034     point.z=point.z/w;
2035 
2036     \textcolor{comment}{// discard points far more than thMeters meters or with not valid disparity (<0)}
2037     \textcolor{keywordflow}{if}(point.z>thMeters || point.z<0) \{
2038         point.x=0.0;
2039         point.y=0.0;
2040         point.z=0.0;
2041         mutex->post();
2042         \textcolor{keywordflow}{return} point;
2043     \} 
2044 
2045     Mat RLrectTmp=this->getRLrect().t();
2046     Mat Tfake = Mat::zeros(0,3,CV\_64F);
2047     Mat P(4,1,CV\_64FC1);
2048     P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2049     P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2050     P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2051     P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2052 
2053     Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2054     P=H*Hrect*P;
2055 
2056     point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2057     point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2058     point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2059 
2060     mutex->post();
2061     \textcolor{keywordflow}{return} point;
2062 
2063 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!project\+Points3\+D@{project\+Points3\+D}}
\index{project\+Points3\+D@{project\+Points3\+D}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{project\+Points3\+D(string camera, vector$<$ Point3f $>$ \&points3\+D, Mat \&\+H)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ Point2f $>$ Stereo\+Camera\+::project\+Points3\+D (
\begin{DoxyParamCaption}
\item[{string}]{camera, }
\item[{vector$<$ Point3f $>$ \&}]{points3\+D, }
\item[{Mat \&}]{H}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a03406c9d31c1b765a8d6ef9641222309}


The method returns the 2\+D projection of a set of 3\+D points in the cartesian space to the specified camera. 


\begin{DoxyParams}{Parameters}
{\em camera} & \char`\"{}left\char`\"{} or \char`\"{}right\char`\"{} camera \\
\hline
{\em point3\+D} & the list of the 3\+D position in the reference frame H \\
\hline
{\em H} & the transformation from the camera reference system to the H reference system \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 2\+D positions. 
\end{DoxyReturn}


Definition at line 2125 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2126 \{
2127     vector<Point2f> points2D;
2128 
2129     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
2130         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
2131         \textcolor{keywordflow}{return} points2D;
2132     \}
2133 
2134     \textcolor{keywordflow}{if}(H.empty())
2135         H=H.eye(4,4,CV\_64FC1);
2136 
2137     mutex->wait();
2138 
2139     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<points3D.size(); i++)
2140     \{   
2141         \textcolor{comment}{// Apply inverse Trasformation for each point}
2142         Point3f point=points3D[i];
2143         Mat P(4,1,CV\_64FC1);
2144         P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2145         P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2146         P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2147         P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2148 
2149         P=H.inv()*P;
2150 
2151         point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2152         point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2153         point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2154 
2155         points3D[i]=point;
2156     \}
2157 
2158     Mat cameraMatrix, distCoeff, rvec, tvec;
2159     rvec=Mat::zeros(3,1,CV\_64FC1);
2160 
2161     \textcolor{keywordflow}{if}(camera==\textcolor{stringliteral}{"left"})
2162     \{
2163         cameraMatrix=this->Kleft;
2164         distCoeff=this->DistL;
2165         Mat R2= Mat::eye(3,3,CV\_64FC1);
2166         Rodrigues(R2,rvec);
2167         tvec=Mat::zeros(3,1,CV\_64FC1);
2168     \}
2169     \textcolor{keywordflow}{else}
2170     \{
2171         cameraMatrix=this->Kright;
2172         distCoeff=this->DistR;
2173         Mat R2= this->R;
2174         Rodrigues(R2,rvec);
2175         tvec=this->T;
2176     \}
2177 
2178     Mat points3Mat(points3D);
2179     projectPoints(points3Mat,rvec,tvec,cameraMatrix,distCoeff,points2D);
2180     mutex->post();
2181 
2182     \textcolor{keywordflow}{return} points2D;
2183 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!rectify\+Images@{rectify\+Images}}
\index{rectify\+Images@{rectify\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{rectify\+Images()}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::rectify\+Images (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ae5ac866c6d4b6c4819b01a918e7b61e0}


The method rectifies the two images\+: it transform each image plane such that pairs conjugate epipolar lines become collinear and parallel to one of the image axes (i.\+e. 

there is 0 disparity on the Y axis). 

Definition at line 483 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
484 \{
485     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
486         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
487         \textcolor{keywordflow}{return};
488     \}
489     \textcolor{keywordflow}{if}(this->imleft.empty() || this->imright.empty()) \{
490           cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
491           \textcolor{keywordflow}{return};
492     \}
493     Size img\_size = this->imleft.size();
494 
495     \textcolor{keywordflow}{if}(cameraChanged)
496     \{
497         mutex->wait();
498         stereoRectify(this->Kleft, this->DistL, this->Kright, this->DistR, img\_size, this->R, this->T, 
      this->RLrect, this->RRrect, this->PLrect, this->PRrect, this->Q, -1);
499 
500         mutex->post();
501     \}
502 
503     \textcolor{keywordflow}{if}(cameraChanged)
504     \{
505         initUndistortRectifyMap(this->Kleft, this->DistL, this->RLrect, this->PLrect, img\_size, CV\_32FC1, 
      this->map11, this->map12);
506         initUndistortRectifyMap(this->Kright,  this->DistR, this->RRrect, this->PRrect, img\_size, CV\_32FC1,
       this->map21, this->map22);
507     \}
508     
509     Mat img1r, img2r;
510     remap(this->imleft, img1r, this->map11, this->map12, cv::INTER\_LINEAR);
511     remap(this->imright, img2r, this->map21,this->map22, cv::INTER\_LINEAR);
512     imgLeftRect=img1r;
513     imgRightRect=img2r;
514 
515 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!save\+Calibration@{save\+Calibration}}
\index{save\+Calibration@{save\+Calibration}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{save\+Calibration(string extrinsic\+File\+Path, string intrinsic\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::save\+Calibration (
\begin{DoxyParamCaption}
\item[{string}]{extrinsic\+File\+Path, }
\item[{string}]{intrinsic\+File\+Path}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a9f06cd4b170ad0ba45b681ee93d64851}


It saves the calibration. 


\begin{DoxyParams}{Parameters}
{\em extrinsic\+File\+Path} & the path of the extrinsic parameters file \\
\hline
{\em intrinsic\+File\+Path} & the path of the intrinsic parameters file \\
\hline
\end{DoxyParams}


Definition at line 405 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
405                                                                                      \{
406 
407     \textcolor{keywordflow}{if}( Kleft.empty() || Kright.empty() || DistL.empty() || DistR.empty() || R.empty() || T.empty()) \{
408             cout << \textcolor{stringliteral}{"Error: cameras are not calibrated! Run the calibration or set intrinsic and extrinsic
       parameters \(\backslash\)n"};
409             \textcolor{keywordflow}{return};
410     \}
411 
412     FileStorage fs(intrinsicFilePath+\textcolor{stringliteral}{".yml"}, CV\_STORAGE\_WRITE);
413     \textcolor{keywordflow}{if}( fs.isOpened() )
414     \{
415         fs << \textcolor{stringliteral}{"M1"} << Kleft << \textcolor{stringliteral}{"D1"} << DistL << \textcolor{stringliteral}{"M2"} << Kright << \textcolor{stringliteral}{"D2"} << DistR;
416         fs.release();
417     \}
418     \textcolor{keywordflow}{else}
419         cout << \textcolor{stringliteral}{"Error: can not save the intrinsic parameters\(\backslash\)n"};
420 
421     fs.open(extrinsicFilePath+\textcolor{stringliteral}{".yml"}, CV\_STORAGE\_WRITE);
422     \textcolor{keywordflow}{if}( fs.isOpened() )
423     \{
424         fs << \textcolor{stringliteral}{"R"} << R << \textcolor{stringliteral}{"T"} << T <<\textcolor{stringliteral}{"Q"} << Q;
425         fs.release();
426     \}
427     \textcolor{keywordflow}{else}
428         cout << \textcolor{stringliteral}{"Error: can not save the intrinsic parameters\(\backslash\)n"};
429 
430 
431 
432     ofstream fout((intrinsicFilePath+\textcolor{stringliteral}{".ini"}).c\_str());
433 
434     \textcolor{comment}{// Left Eye}
435     fout << \textcolor{stringliteral}{"[left]"} << endl;
436     fout << \textcolor{stringliteral}{"fx "} << Kleft.at<\textcolor{keywordtype}{double}>(0,0) << endl;
437     fout << \textcolor{stringliteral}{"fy "} << Kleft.at<\textcolor{keywordtype}{double}>(1,1) << endl;
438     fout << \textcolor{stringliteral}{"cx "} << Kleft.at<\textcolor{keywordtype}{double}>(0,2) << endl;
439     fout << \textcolor{stringliteral}{"cy "} << Kleft.at<\textcolor{keywordtype}{double}>(1,2) << endl;
440     fout << \textcolor{stringliteral}{"k1 "} << DistL.at<\textcolor{keywordtype}{double}>(0,0) << endl;
441     fout << \textcolor{stringliteral}{"k2 "} << DistL.at<\textcolor{keywordtype}{double}>(1,0) << endl;
442     fout << \textcolor{stringliteral}{"p1 "} << DistL.at<\textcolor{keywordtype}{double}>(2,0) << endl;
443     fout << \textcolor{stringliteral}{"p2 "} << DistL.at<\textcolor{keywordtype}{double}>(3,0) << endl;
444 
445     \textcolor{comment}{// Right Eye}
446     fout << \textcolor{stringliteral}{"[right]"} << endl;
447     fout << \textcolor{stringliteral}{"fx "} << Kright.at<\textcolor{keywordtype}{double}>(0,0) << endl;
448     fout << \textcolor{stringliteral}{"fy "} << Kright.at<\textcolor{keywordtype}{double}>(1,1) << endl;
449     fout << \textcolor{stringliteral}{"cx "} << Kright.at<\textcolor{keywordtype}{double}>(0,2) << endl;
450     fout << \textcolor{stringliteral}{"cy "} << Kright.at<\textcolor{keywordtype}{double}>(1,2) << endl;
451     fout << \textcolor{stringliteral}{"k1 "} << DistR.at<\textcolor{keywordtype}{double}>(0,0) << endl;
452     fout << \textcolor{stringliteral}{"k2 "} << DistR.at<\textcolor{keywordtype}{double}>(1,0) << endl;
453     fout << \textcolor{stringliteral}{"p1 "} << DistR.at<\textcolor{keywordtype}{double}>(2,0) << endl;
454     fout << \textcolor{stringliteral}{"p2 "} << DistR.at<\textcolor{keywordtype}{double}>(3,0) << endl;
455 
456     fout.close();
457 
458 
459 
460 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Expected\+Position@{set\+Expected\+Position}}
\index{set\+Expected\+Position@{set\+Expected\+Position}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Expected\+Position(\+Mat \&\+Rot, Mat \&\+Tran)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Expected\+Position (
\begin{DoxyParamCaption}
\item[{Mat \&}]{Rot, }
\item[{Mat \&}]{Tran}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a9ecb303d7b36eaf5f086d8ddebd29b95}


The function set the expected Rotation and Translation parameters for the current image pair. 

They can be computed using the Kinematics. 
\begin{DoxyParams}{Parameters}
{\em Rot} & 3x3 matrix representing the rotation between the left and the right camera. \\
\hline
{\em Tran} & 3x1 vector representing the translation between the left and the right camera. \\
\hline
\end{DoxyParams}


Definition at line 2363 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2364 \{
2365     R\_exp=Rot;
2366     T\_exp=Tran; 
2367 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Images@{set\+Images}}
\index{set\+Images@{set\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Images(\+Ipl\+Image $\ast$first\+Img, Ipl\+Image $\ast$second\+Img)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Images (
\begin{DoxyParamCaption}
\item[{Ipl\+Image $\ast$}]{first\+Img, }
\item[{Ipl\+Image $\ast$}]{second\+Img}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a5e24f7d17a11adb4a6310df7f7e2de5b}


It stores in memory a couple of images. 


\begin{DoxyParams}{Parameters}
{\em first\+Img} & the images acquired from the first (main) camera \\
\hline
{\em second\+Img} & the images acquired from the second (secondary) camera \\
\hline
\end{DoxyParams}


Definition at line 180 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
180                                                               \{
181        this->imleft=left;
182        this->imright=right;
183 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Intrinsics@{set\+Intrinsics}}
\index{set\+Intrinsics@{set\+Intrinsics}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Intrinsics(\+Mat \&\+K1, Mat \&\+K2, Mat \&\+Dist1, Mat \&\+Dist2)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Intrinsics (
\begin{DoxyParamCaption}
\item[{Mat \&}]{K1, }
\item[{Mat \&}]{K2, }
\item[{Mat \&}]{Dist1, }
\item[{Mat \&}]{Dist2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a54754623497c8dddb61f520e17f465f8}


It sets the intrinsic parameters. 


\begin{DoxyParams}{Parameters}
{\em K1} & 3x3 camera matrix of the first camera. \\
\hline
{\em K2} & 3x3 camera matrix of the second camera. \\
\hline
{\em Dist1} & 4x1 distortion coefficients vector of the first camera. \\
\hline
{\em Dist2} & 4x1 distortion coefficients vector of the second camera. \\
\hline
\end{DoxyParams}


Definition at line 1873 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1873                                                                          \{
1874     this->mutex->wait();
1875     this->Kleft=KL;
1876     this->Kright=KR;
1877     this->DistL=DistL;
1878     this->DistR=DistR;
1879 
1880     \textcolor{keywordflow}{if}(!this->R.empty() && !this->T.empty())
1881         updatePMatrix();
1882     this->cameraChanged=\textcolor{keyword}{true};
1883     buildUndistortRemap();
1884     this->mutex->post();
1885 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Matches@{set\+Matches}}
\index{set\+Matches@{set\+Matches}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Matches(std\+::vector$<$ cv\+::\+Point2f $>$ \&points\+L, std\+::vector$<$ cv\+::\+Point2f $>$ \&points\+R)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Matches (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ cv\+::\+Point2f $>$ \&}]{points\+L, }
\item[{std\+::vector$<$ cv\+::\+Point2f $>$ \&}]{points\+R}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ae683fafa11ea73e4b4c278402be259b6}


The function initialize the matches of the current image pair. 

For example matches can be computed in G\+P\+U with higher framerate. 
\begin{DoxyParams}{Parameters}
{\em points\+L} & vector of Point2f representing the keypoints on the left image. \\
\hline
{\em points\+R} & vector of Point2f representing the keypoints on the right image. \\
\hline
\end{DoxyParams}


Definition at line 2355 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2356 \{
2357     PointsL=pointsL;
2358     PointsR=pointsR;
2359 
2360 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Rotation@{set\+Rotation}}
\index{set\+Rotation@{set\+Rotation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Rotation(\+Mat \&\+Rot, int mode=0)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Rotation (
\begin{DoxyParamCaption}
\item[{Mat \&}]{Rot, }
\item[{int}]{mode = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a1329b3894d527e1505618f57a1304624}


It sets the rotation matrix (if known) between the first and the second camera. 


\begin{DoxyParams}{Parameters}
{\em Rot} & the 3x3 rotation matrix. \\
\hline
{\em mode} & the following values are allowed\+: {\bfseries mode=0} the rotation matrix R is set equal to Rot. {\bfseries mode=1} the rotation matrix R is set equal to Rot$\ast$\+R. {\bfseries mode=2} the rotation matrix R is set equal to Rot$\ast$\+Rinit. \\
\hline
\end{DoxyParams}


Definition at line 1448 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1448                                                 \{
1449     this->mutex->wait();
1450     \textcolor{keywordflow}{if}(mul==0)
1451         this->R=Rot;
1452     \textcolor{keywordflow}{if}(mul==1)
1453         this->R=Rot*R;
1454     \textcolor{keywordflow}{if}(mul==2)
1455         this->R=Rot*Rinit;
1456         
1457     \textcolor{keywordflow}{if}(R\_exp.empty())
1458        R\_exp=R;
1459     this->updatePMatrix();
1460     this->cameraChanged=\textcolor{keyword}{true};
1461     this->mutex->post();
1462 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Translation@{set\+Translation}}
\index{set\+Translation@{set\+Translation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Translation(\+Mat \&\+Tras, int mul=0)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Translation (
\begin{DoxyParamCaption}
\item[{Mat \&}]{Tras, }
\item[{int}]{mul = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a7b10f1218e8e70f47b22080ba1820d39}


It sets the translation vector (if known) between the first and the second camera. 


\begin{DoxyParams}{Parameters}
{\em Tras} & the 3x1 translation matrix. \\
\hline
{\em mode} & the following values are allowed\+: {\bfseries mode=0} the translation vector T is set equal to Tras. {\bfseries mode=1} the translation vector T is set equal to Tras+\+T. {\bfseries mode=2} the translation vector T is set equal to Tras+\+Tinit. \\
\hline
\end{DoxyParams}


Definition at line 1464 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1464                                                     \{
1465     this->mutex->wait();
1466     \textcolor{keywordflow}{if}(mul==0)
1467         this->T=Tras;
1468     \textcolor{keywordflow}{if}(mul==1)
1469         this->T=Tras+T;
1470     \textcolor{keywordflow}{if}(mul==2)
1471         this->T=Tras+Tinit;
1472 
1473     \textcolor{keywordflow}{if}(T\_exp.empty())
1474         T\_exp=T;
1475         
1476     \textcolor{keywordflow}{if}(!this->Kleft.empty() && !this->Kright.empty())
1477         this->updatePMatrix();
1478     this->cameraChanged=\textcolor{keyword}{true};
1479     this->mutex->post();
1480 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!stereo\+Calibration@{stereo\+Calibration}}
\index{stereo\+Calibration@{stereo\+Calibration}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{stereo\+Calibration(vector$<$ string $>$ image\+List, int board\+Width, int board\+Height, float sqsize=1.\+0)}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::stereo\+Calibration (
\begin{DoxyParamCaption}
\item[{vector$<$ string $>$}]{image\+List, }
\item[{int}]{board\+Width, }
\item[{int}]{board\+Height, }
\item[{float}]{sqsize = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a398f45eeefe7979a834659cfbb7a6961}


It performs the stereo camera calibration. 

(see stereo\+Calibration module) 
\begin{DoxyParams}{Parameters}
{\em image\+List} & is the list containing the paths of the images with the chessboard patterns. even indices refer to Left camera images (i.\+e. main camera images), while odd indices refer to Right camera images. \\
\hline
{\em board\+Width} & the number of inner corners in the width direction of the chess board pattern (see stereo\+Calibration module) \\
\hline
{\em board\+Height} & the number of inner corners in the height direction of the chess board pattern (see stereo\+Calibration module) \\
\hline
{\em sqsize} & the size of the square of the chess board pattern. It is needed for a metric reconstruction. \\
\hline
\end{DoxyParams}


Definition at line 198 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
198                                                                                                            
      \{
199     Size boardSize;
200     boardSize.width=boardWidth;
201     boardSize.height=boardHeight;
202     runStereoCalib(imagelist, boardSize,sqsize);
203 
204 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulate\+Known\+Disparity@{triangulate\+Known\+Disparity}}
\index{triangulate\+Known\+Disparity@{triangulate\+Known\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulate\+Known\+Disparity(float u, float v, float d, Mat \&\+H)}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulate\+Known\+Disparity (
\begin{DoxyParamCaption}
\item[{float}]{u, }
\item[{float}]{v, }
\item[{float}]{d, }
\item[{Mat \&}]{H}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a761ea623c4cde38b4fa1d798ef09b7ae}


It performs the metric triangulation given the pixel coordinates on the first image and the disparity between the two R\+E\+C\+T\+I\+F\+I\+E\+D images. 

The 3\+D Point is w.\+r.\+t the system defined by the parameter H. 
\begin{DoxyParams}{Parameters}
{\em u} & the pixel x coordinate in the first image. \\
\hline
{\em v} & the pixel y coordinate in the first image. \\
\hline
{\em d} & the disparity on the x coordinate between the two rectified images. \\
\hline
{\em H} & the 4x4 rototranslation matrix of the system can be an empty matrix. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3\+D point w.\+r.\+t. the reference system defined by H. 
\end{DoxyReturn}


Definition at line 2066 of file stereo\+Camera.\+cpp.



References get\+R\+Lrect().


\begin{DoxyCode}
2067 \{
2068     mutex->wait();
2069     \textcolor{keywordflow}{if}(Q.empty())
2070     \{
2071         cout << \textcolor{stringliteral}{"Run rectifyImages() method first!"} << endl;
2072         Point3f point;
2073         point.x=0.0;
2074         point.y=0.0;
2075         point.z=0.0;
2076         mutex->post();
2077         \textcolor{keywordflow}{return} point;
2078     \}
2079 
2080     \textcolor{keywordflow}{if}(H.empty())
2081         H=H.eye(4,4,CV\_64FC1);
2082 
2083     Point3f point;
2084 
2085     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) d*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
2086     point.x= (float)((\textcolor{keywordtype}{float}) (u)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
2087     point.y=(float)((\textcolor{keywordtype}{float}) (v)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
2088     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
2089 
2090     \textcolor{comment}{// Rectified Camera System}
2091     point.x=point.x/w;
2092     point.y=point.y/w;
2093     point.z=point.z/w;
2094 
2095     \textcolor{comment}{// We transform to H Coordinate System}
2096     Mat RLrectTmp=this->getRLrect().t(); \textcolor{comment}{// First it transform the point to the unrectified camera
       reference system}
2097     Mat Tfake = Mat::zeros(0,3,CV\_64F);
2098     Mat P(4,1,CV\_64FC1);
2099     P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2100     P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2101     P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2102     P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2103 
2104     Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2105     P=H*Hrect*P;
2106 
2107     point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2108     point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2109     point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2110 
2111     mutex->post();
2112     \textcolor{keywordflow}{return} point;
2113 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation@{triangulation}}
\index{triangulation@{triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulation(\+Point2f \&point1, Point2f \&point2)}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Point2f \&}]{point2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3c8ef84424fa111c63437a3db8f04333}


It performs the triangulation using the stored in the internal P1 and P2 3x4 \hyperlink{classCamera}{Camera} Matrices. 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2\+D point coordinates in the first image. \\
\hline
{\em point2} & the 2\+D point coordinates in the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3\+D point wrt the first camera reference system. 
\end{DoxyReturn}


Definition at line 775 of file stereo\+Camera.\+cpp.



Referenced by chierality().


\begin{DoxyCode}
775                                                                            \{
776       
777       Point3f point3D;
778       Mat J=Mat(4,4,CV\_64FC1);
779       J.setTo(0);
780       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<4; j++) \{
781 
782             \textcolor{keywordtype}{int} rowA=0;
783             \textcolor{keywordtype}{int} rowB=2;
784 
785             J.at<\textcolor{keywordtype}{double}>(0,j)=(pointleft.x*this->Pleft.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pleft.at<\textcolor{keywordtype}{double}>(rowA,j)
      );
786             J.at<\textcolor{keywordtype}{double}>(2,j)=(pointRight.x*this->Pright.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pright.at<\textcolor{keywordtype}{double}>(rowA
      ,j));
787 
788             rowA=1;
789             
790             J.at<\textcolor{keywordtype}{double}>(1,j)=(pointleft.y*this->Pleft.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pleft.at<\textcolor{keywordtype}{double}>(rowA,j)
      );
791             J.at<\textcolor{keywordtype}{double}>(3,j)=(pointRight.y*this->Pright.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pright.at<\textcolor{keywordtype}{double}>(rowA
      ,j));
792         \}
793         SVD decom(J);
794         Mat V= decom.vt;
795 
796         point3D.x=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,0))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
797         point3D.y=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,1))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));     
798         point3D.z=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,2))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
799         \textcolor{keywordflow}{return} point3D;
800 
801 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation@{triangulation}}
\index{triangulation@{triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulation(\+Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Point2f \&}]{point2, }
\item[{Mat}]{Camera1, }
\item[{Mat}]{Camera2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ab68c8d3bd07f542243d681fbe8c8c6b7}


It performs the triangulation (H\+Z Chap 12.\+2 homogenous solution). 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2\+D point coordinates in the first image. \\
\hline
{\em point2} & the 2\+D point coordinates in the second image. \\
\hline
{\em Camera1} & the 3x4 camera matrix of the first image. \\
\hline
{\em Camera2} & the 3x4 camera matrix of the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3\+D point wrt the first camera reference system. 
\end{DoxyReturn}


Definition at line 1288 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1288                                                                                                      \{
1289 
1290       Point3f point3D;
1291       Mat J=Mat(4,4,CV\_64FC1);
1292       J.setTo(0);
1293                 
1294       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<4; j++) \{
1295 
1296             \textcolor{keywordtype}{int} rowA=0;
1297             \textcolor{keywordtype}{int} rowB=2;
1298 
1299             J.at<\textcolor{keywordtype}{double}>(0,j)=(pointleft.x*Camera1.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera1.at<\textcolor{keywordtype}{double}>(rowA,j));
1300             J.at<\textcolor{keywordtype}{double}>(2,j)=(pointRight.x*Camera2.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera2.at<\textcolor{keywordtype}{double}>(rowA,j));
1301 
1302             rowA=1;
1303             
1304             J.at<\textcolor{keywordtype}{double}>(1,j)=(pointleft.y*Camera1.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera1.at<\textcolor{keywordtype}{double}>(rowA,j));
1305             J.at<\textcolor{keywordtype}{double}>(3,j)=(pointRight.y*Camera2.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera2.at<\textcolor{keywordtype}{double}>(rowA,j));
1306         \}
1307         SVD decom(J);
1308         Mat V= decom.vt;
1309 
1310        \textcolor{comment}{// printMatrix(V);}
1311         
1312         \textcolor{comment}{/*Mat sol=Mat(4,1,CV\_64FC1);}
1313 \textcolor{comment}{        sol.at<double>(0,0)=V.at<double>(0,0);}
1314 \textcolor{comment}{        sol.at<double>(1,0)=V.at<double>(1,1);}
1315 \textcolor{comment}{        sol.at<double>(2,0)=V.at<double>(2,2);}
1316 \textcolor{comment}{        sol.at<double>(3,0)=V.at<double>(3,3);}
1317 \textcolor{comment}{        }
1318 \textcolor{comment}{        Mat test=J*sol;}
1319 \textcolor{comment}{        }
1320 \textcolor{comment}{        printMatrix(test);*/}
1321         point3D.x=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,0))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
1322         point3D.y=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,1))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));     
1323         point3D.z=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,2))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
1324         \textcolor{keywordflow}{return} point3D;
1325 
1326 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation\+L\+S@{triangulation\+L\+S}}
\index{triangulation\+L\+S@{triangulation\+L\+S}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulation\+L\+S(\+Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulation\+L\+S (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Point2f \&}]{point2, }
\item[{Mat}]{Camera1, }
\item[{Mat}]{Camera2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_aaef25d8723eefdbab6e27c348492126b}


It performs the least square triangulation (H\+Z Chap 12.\+2 Inhomogenous solution). 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2\+D point coordinates in the first image. \\
\hline
{\em point2} & the 2\+D point coordinates in the second image. \\
\hline
{\em Camera1} & the 3x4 camera matrix of the first image. \\
\hline
{\em Camera2} & the 3x4 camera matrix of the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3\+D point wrt the first camera reference system. 
\end{DoxyReturn}
\index{Stereo\+Camera@{Stereo\+Camera}!undistort\+Images@{undistort\+Images}}
\index{undistort\+Images@{undistort\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{undistort\+Images()}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::undistort\+Images (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a2751f357e5fabc7099303d45425208d7}


It undistorts the images. 

\begin{DoxyNote}{Note}
Set undistortion coefficients before using this method. 
\end{DoxyNote}


Definition at line 1421 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1421                                    \{
1422     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
1423         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
1424         \textcolor{keywordflow}{return};
1425     \}
1426     \textcolor{keywordflow}{if}(this->imleft.empty() || this->imright.empty()) \{
1427           cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
1428           \textcolor{keywordflow}{return};
1429     \}
1430         
1431     undistort(this->imleft,this->imleftund,this->Kleft,this->DistL);
1432     undistort(this->imright,this->imrightund,this->Kright,this->DistR);
1433 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/dev/icub-\/contrib-\/iit/stereo-\/vision/lib/include/i\+Cub/stereo\+Vision/stereo\+Camera.\+h\item 
C\+:/dev/icub-\/contrib-\/iit/stereo-\/vision/lib/src/stereo\+Camera.\+cpp\end{DoxyCompactItemize}
